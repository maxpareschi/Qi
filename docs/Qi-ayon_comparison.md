# Qi vs. Ayon-Core: Architectural Comparison

## Architectural Philosophy and Structure

**Qi** is a new VFX pipeline framework and desktop app built with Python and web technologies. It emphasizes a modular core with *services* and *addons* as first-class concepts. Qi’s UI is web-based (embedded browser windows) and it uses a WebSocket message hub for internal communication, reflecting a modern decoupled design. It’s engineered to integrate with external production trackers (like Ftrack) via pluggable provider addons, rather than embedding a fixed backend. The architecture is still evolving – many components are planned or in progress per the roadmap (e.g. bundle manager, addon system).

**Ayon-Core**, by contrast, is the foundational client of the AYON pipeline (successor to OpenPype) and is more mature. It provides the base building blocks for all other AYON addons and integrations, handling their discovery and initialization. Ayon-core is tightly coupled with the **AYON server** (which replaces external trackers), and its philosophy is to have a lean core addon with most pipeline integrations delivered as separate addons. The UI in Ayon is a Qt-based tray application and tools, consistent with OpenPype’s legacy. In essence, Qi is designed for flexibility and external extensibility (multiple possible backends), whereas Ayon-core assumes a unified AYON ecosystem (server + client) with controlled extension points.

Technically, both projects share a **plugin-based extensibility philosophy** but implement it differently. Qi cleanly separates a lightweight core (services like Hub, GUI, Settings, etc.) from feature addons. Ayon-core itself is actually one essential addon (“core”) in the AYON system alongside many others, but as a project it still contains substantial functionality (including some host integrations that are being split out in newer versions). Qi uses a local FastAPI server to serve its web UIs and a few HTTP APIs, whereas Ayon-core interacts with the remote AYON server via REST/GraphQL and uses local Python APIs for UI and logic.

**Summary:** Qi’s architecture is built around **decoupling and networked communication (web UI + WebSocket IPC)**, aiming for adaptability to different pipelines. Ayon-core’s architecture is **monolithic but plugin-driven**, born from a production-proven pipeline (OpenPype) and now refactoring toward more modular addons within the AYON platform. Both share the goal of a highly extensible DCC integration framework, but Qi is earlier-stage with a modern spin, while Ayon inherits established patterns and a dedicated backend.

## Addon Discovery and Lifecycle

**Qi Addon Lifecycle:** Qi defines a clear two-phase addon loading lifecycle to handle critical core services vs. regular extensions. On startup, Qi’s `QiAddonManager` first discovers all addons in configured paths. **Phase 1** loads only provider addons: any addon declaring a **role** of “auth” or “db” (authentication or database provider) is initialized first. Qi enforces that exactly one auth provider and one db provider are present – if missing or duplicated, startup fails. Each provider addon is then immediately *discovered* and *registered* before proceeding. This ensures that core services (login, project data) are available for the rest of the system. After user authentication, **Phase 2** loads all other addons: Qi instantiates them, calls their `discover()` and `register()` methods, and adds them into the running system. Once all are registered, Qi calls an `install()` hook on every addon to perform any cross-addon initialization post-registration. Finally, when shutting down, Qi will call each addon’s `close()` for cleanup. This lifecycle (discover → register → install → close) is explicitly defined in `QiAddonBase` to ensure addons can hook at the right times.

> **Qi addon roles and lifecycle:** Qi addons may declare a unique `role` (e.g. `'auth'` or `'db'`) if they provide an essential service; otherwise they are regular addons. All addons have `discover()` and `register()` phases (with `register()` required to attach bus handlers, routes, CLI commands, etc.) and an optional `install()` for post-setup logic. Providers are loaded and registered in Phase 1, while others are queued for Phase 2 after auth.

**Ayon-Core Addon Lifecycle:** Ayon’s addon system is a direct evolution of OpenPype’s. In Ayon-core, addon discovery and loading happen mostly in one go. On launcher start, Ayon-core determines the active **bundle** (which specifies which addons and versions to use) by querying the AYON server, then loads each addon from disk (or developer path) accordingly. The `AddonsManager` in Ayon-core will import all addon modules and then instantiate every class that subclasses the base `AYONAddon`. There isn’t a distinct two-phase separation for providers – since AYON assumes its own authentication mechanism (login to the AYON server) and a built-in database, it doesn’t treat “auth” or “db” as pluggable addons the way Qi does. In fact, Qi’s concept of swappable auth/db providers is not needed in Ayon – those concerns are handled by the core AYON platform. As a result, **Ayon loads all enabled addons in a single phase**, skipping only the “core” addon (itself) during discovery to avoid recursion. After instantiation, Ayon then calls each addon’s `connect_with_addons()` method to let addons perform any inter-addon hookup now that all are loaded.

Notably, Ayon’s `AYONAddon` base class doesn’t define explicit “register”/“install” steps – initialization is done in the constructor (`initialize()` method) and any cross-linking in `connect_with_addons()`. However, Ayon does have lifecycle-like hooks per addon: for example, addons can implement `ensure_is_process_ready()` to handle pre-launch prep, or `on_host_install()` to handle events when a DCC host finishes its init (more in DCC Integration below). Cleanup in Ayon is handled by the application on exit (there’s no explicit addon `close()`; resources are freed on process termination or handled internally).

**Summary:** Qi’s addon lifecycle is more structured and multi-staged: it explicitly distinguishes *critical service providers* from regular addons and provides formal phases (discover/register/install/close). This is motivated by Qi’s need to remain backend-agnostic and allow drop-in replacements for auth or project data. Ayon-core’s addon loading is more straightforward: all addons defined in the active bundle are discovered and initialized at startup without special phasing (beyond possibly the AYON server syncing what to load). Ayon trusts the central server config to only include compatible addons, whereas Qi performs checks at runtime for required providers. Qi’s approach is philosophically about *failing fast* if a core piece is missing and allowing maximum flexibility in providers, while Ayon’s is about *loading everything needed* for the configured pipeline with minimal fuss.

## Plugin System and Extensibility

Both Qi and Ayon use a layered plugin model – addons are high-level extensions, and within each addon there are finer-grained **plugins** (publish plugins, loaders, actions, etc.). The difference lies in how these plugins are defined and discovered.

**Qi’s Plugin Model:** In Qi, an addon can contain specialized plugin classes in well-known subdirectories (create, load, publish, etc.). All plugin classes subclass `QiPluginBase`, which defines a simple life cycle: `discover()`, `register()`, and `process()`. This is essentially a micro-framework for plugin logic: on addon load, Qi can instantiate each plugin and call discover/register as needed (or integrate with the Hub). For example, a “Loader” plugin might discover available asset files, register message handlers or menu commands, and then implement `process()` to actually import an asset when triggered. Qi also integrates with **Pyblish** for publishing: it designates “Publish” plugins as those subclassing QiPluginBase *and* Pyblish’s plugin classes, so that Pyblish can handle their execution during the publish process. The Qi spec defines five primary plugin types: creators, loaders, hooks, publish plugins, and actions – each type extends a common base but provides different functionality in the pipeline. In short, Qi’s plugin architecture leans towards **class-based plugins with explicit registration**. The addon’s `register()` method is expected to register all its plugin classes into the system (for example, attaching their handlers to the Hub topics or the UI).

> **Qi plugin lifecycle:** Each `QiPluginBase` implements `discover()`, `register()`, and `process()` which the system calls in sequence. This mirrors the addon lifecycle but at a finer granularity – it allows, for instance, a publish plugin to prepare any data needed (discover), register its presence (e.g. add a menu item or bus handler), and later be executed (process) asynchronously via the Hub. This design is meant to encapsulate plugin logic cleanly and enable future features like conditional discovery or lazy loading of plugins.

**Ayon’s Plugin Model:** Ayon-core inherits the plugin concepts from OpenPype/Avalon. Instead of each plugin being an instantiated class at startup, Ayon organizes plugins *by file path conventions*. Addons that implement the **`IPluginPaths` interface** can return a dictionary of plugin folder paths for various plugin types (publish, create, load, actions, etc.). For example, an addon might declare that it has publish plugins located in `"{addon_dir}/plugins/publish"` or load plugins in `"{addon_dir}/plugins/load"`. The Ayon pipeline then **collects these paths** and lets the respective subsystems (the publisher tool, the loader UI, etc.) discover actual plugin classes by scanning those directories. This approach means that Ayon’s plugins are typically simple Python modules (often deriving from a common base like Pyblish’s plugin class or OpenPype’s Creator/Loader base) placed in the filesystem, rather than explicitly constructed objects at app start.

At runtime, when a publish is triggered, Ayon will load all plugins from the registered publish paths (e.g. via Pyblish’s discovery which looks at those folders). Similarly, for loading assets, Ayon’s loader tool knows to scan “create” or “load” plugin paths provided by each addon to populate available actions. The `IPluginPaths` interface provides a structured way for addons to contribute to these global plugin pools. This is **plugin encapsulation by filesystem**: plugins are kept within their addon’s directory and only discovered when needed, avoiding the need to keep every plugin in memory at all times.

In Ayon-core’s code, there is no single `register_plugins()` call at startup akin to Qi. Instead, Ayon’s addon base ensures that any needed plugin paths or environment variables are exposed. For instance, after all addons are initialized, Ayon calls `collect_global_environments()` which can include env vars pointing to plugin locations. One of those env vars might be Pyblish’s plugin search path, etc. Also, some addons (like an Avalon integration addon) might programmatically register plugins with the host app’s APIs in their `initialize()` or `connect_with_addons()`.

**Comparison:** Qi’s plugin framework is more explicit and code-driven – each plugin is an object that can hook into the Qi hub or CLI. This can make dynamic behaviors (like enabling/disabling a plugin or hot-reloading it) easier to manage via code. Ayon’s approach is more data-driven – plugins are scripts on disk discovered via known directories, which aligns with the way many VFX pipelines handle publish and load actions (just drop a new plugin file in the folder and restart the tool to pick it up). Qi could benefit from aspects of Ayon’s approach: for example, using a **manifest or registry of plugin paths** to allow adding new plugins without modifying code, and segregating plugin discovery to when it’s needed (lazy loading). On the other hand, Qi’s unified plugin base with lifecycle methods provides a consistent interface that Ayon’s plugins (spread across different frameworks: Pyblish, Avalon, custom) lack. Ayon’s solution to manage multiple plugin types was to define interfaces like `IPluginPaths` for file-based discovery, whereas Qi uses a unified in-memory registration approach. Both aim to keep plugins modular, but Qi’s method may yield better runtime flexibility, while Ayon’s yields simplicity in adding plugins.

## Settings Architecture

**Qi Settings Architecture:** Qi has a dedicated configuration system centered on the `QiSettings` and `QiSettingsManager` classes. QiSettings is a hierarchical schema built on **Pydantic models**, providing structured, type-validated settings with default values and even UI metadata. This allows Qi to attach settings definitions to any component or addon – indeed, addons can declare their own settings schema via `get_settings_definition()` returning a `QiGroup` (a grouping of settings properties). The `QiSettingsManager` at runtime is responsible for building the full settings hierarchy and merging in any overrides. The planned strategy (per Qi’s specs and Q\&A) is to support layered overrides at the *bundle level*, *project level*, and possibly *user level*: Qi will load defaults (from code), then apply bundle-specific overrides, then project-specific overrides, yielding the effective settings. These overrides may be stored in an external database or file. In the current implementation, Qi has a functioning settings schema system and is working on the persistence layer: initially a simple file/JSON via a `FileDBAdapter` is planned, with future integration to Ftrack or other trackers for project-specific config via a `QiDbManager` interface. Qi’s use of Pydantic means each setting can carry validation and even UI hinting out-of-the-box, which is great for automatically generating settings dialogs. The FastAPI server in Qi exposes a REST API for settings (e.g. `GET /settings` to retrieve the merged config, `PATCH /settings/{addon}` to apply changes), and the WebSocket bus also provides `config.get` and `config.patch` RPC calls for on-the-fly updates. This indicates Qi is aiming for **live editable settings** in the UI, with immediate propagation via its bus (e.g. broadcasting a `config.updated` event on change). Overall, Qi’s settings architecture is modern, leveraging schema-driven development for maintainability.

> **Qi settings status:** The hierarchical schema definitions (via `QiSettings` and nested `QiGroup`/`QiProp` models) are already implemented and passing tests. The `QiSettingsManager` to merge and persist settings is planned as one of the next steps. Qi’s design includes both a file-based storage for user overrides and hooks to an external database service (initially a mock, later Ftrack) for project-level data.

**Ayon-Core Settings Architecture:** Ayon’s settings system is partly on the client and partly on the server. In OpenPype (the predecessor), there was a concept of **“studio (system) settings”** vs **“project settings”** stored in a database (MongoDB or an API), with a GUI to edit them. Ayon continues this, but now the AYON server likely holds the canonical settings in its database (possibly accessible via a GraphQL or REST API). The Ayon-core client on startup retrieves the “studio settings” for the site. In code, this is seen in the `AddonsManager` initialization: if no settings dict is provided, it calls `get_studio_settings()` to fetch the current settings. Those settings (a nested dict) are then passed into each addon’s constructor so that the addon can read its relevant portion. (Typically, each addon will pick out the section of the settings relevant to it – e.g., the “Maya” addon looks at settings\["maya"] etc.) Project-specific overrides come into play when working within a project context: for example, when a DCC is launched for a specific project, the addon might query project settings via the AYON API. Ayon’s server provides an interface to query effective settings per project, and the client’s `ayon_api` can retrieve that. The design is a **pull model**: the client asks the server for settings when needed (and possibly caches them), whereas Qi’s design leans toward a **push model** of distributing settings at startup and updating via events.

However, Ayon does have a structured schema for settings on the server side. The AYON server defines all configurable settings (likely also using Pydantic or a similar schema mechanism, given modern practices). The presence of a `conversion.py` and structured default values in the server code suggests that the server knows how to merge studio settings with project overrides and present them to clients. The Ayon UI (web-based or in the desktop) allows editing those settings, which then propagate to all users via the server.

On the client side, Ayon-core also supports *local* or user settings for certain things. For example, `ayon_core.lib.local_settings` might handle preferences specific to the user/machine (not stored on server). But for pipeline config that affects DCC behavior, the server is the source of truth.

**Key differences:** Qi embeds the settings logic into the client to allow standalone operation and quick iteration (essential while Qi’s backend is not fully implemented). Ayon offloads much of that to the server – the advantage is central management and multi-user consistency, at the cost of needing a server round-trip for changes. Qi’s approach with Pydantic schemas and a built-in API for settings gives developers immediate feedback and type safety, something Ayon likely achieves with its own schemas but perhaps not exposed on the client in the same way. One notable Ayon feature Qi plans to emulate is **hierarchical override merging**: Ayon has long supported global vs project vs per-site overrides. Qi explicitly plans to merge default → bundle → project settings in that order, which is conceptually identical to Ayon’s layering of system defaults vs project overrides.

**Opportunities for Qi:** Qi could integrate a **settings editing UI** akin to Ayon’s, since Qi already attaches UI metadata to settings. Learning from Ayon, Qi should enforce that **all addon settings are part of a global schema** (Ayon’s approach of one big settings structure ensures consistency – Qi’s `QiSettings` seems to follow this by aggregating addon schemas). Additionally, Qi might later provide an option to sync settings to a server or shared storage, for multi-user teams, just as Ayon does through its server. The current design of Qi is well-aligned with these goals.

## Environment & Bundle Handling

**Bundle Concept:** Both Qi and Ayon-core organize addons via the idea of **bundles** – a controlled set of addons (with specific versions) that constitute a coherent pipeline configuration.

* In **Qi**, a *Bundle* is defined as “a collection of addons and environments that specify a reproducible collection”. Qi supports different bundle types or statuses: e.g. a *Production* bundle (the primary pipeline config), a *Staging* bundle (for testing new updates), and possibly multiple *Dev* bundles for local development. Only one production and one staging bundle can exist at a time, and bundles can be activated per context. The QiBundleManager (not yet implemented as of the current roadmap) will manage what addons are included in each bundle and handle environment variable setups for launching DCCs under that bundle. In practice, this means Qi will allow quickly switching pipeline configurations – for instance, launching Maya under the “staging” bundle to test upcoming changes, while keeping “production” bundle as default. Qi plans to persist bundle definitions likely via its DbManager (which could tie into Ftrack project data or a local file). In Phase 2 of Qi’s roadmap, building the Bundle engine is a major step.

* In **Ayon-core**, bundles are already a functional concept integrated with the AYON server. Each bundle is defined server-side (with a name and a list of addons and their version pins). When the Ayon launcher starts, it looks for an environment variable `AYON_BUNDLE_NAME` to decide which bundle to use. It then asks the server for the details of that bundle (which addons to load). Ayon-core will only load the addons specified in the active bundle, and it even supports per-project bundle selection (the AYON system can map projects to specific bundles). This provides a powerful way to test new pipeline versions on a subset of projects or users. Ayon also has a concept of **“dev mode bundles”** for development: the forum notes mention an “Ayon dev mode” where developers can create a special dev bundle and override addon paths for their own user. This implies the AYON system can have bundles marked for development which pull addon code from a local path instead of an official release (very useful for testing code changes without affecting others).

Both systems use environment variables as part of bundle handling: Qi will likely use an env var or config file to specify the current bundle (similar to how QiLaunchConfig might hold a default bundle), while Ayon explicitly uses `AYON_BUNDLE_NAME` and possibly other env vars (like `AYON_DEV` flags) to toggle behavior.

**Environment Setup:** A critical aspect of bundle management is setting environment variables for DCC processes. Qi and Ayon address this slightly differently:

* **Qi environment setup:** Qi’s BundleManager will define environment variables that need to be set when launching any DCC in that bundle. Qi’s spec alludes to this by saying a bundle is a collection of addons *and environments*. In practice, Qi will likely store key environment variables (like PYTHONPATH entries for each addon’s `lib/` folder, or tool-specific env vars) as part of the bundle definition. When Qi spawns a host process, it can combine base env vars from all enabled addons plus bundle-specific ones. Indeed, Qi’s addon model could allow each addon to contribute env vars: though QiAddonBase doesn’t yet have a `get_environment()` method, Qi could easily add something similar to how Ayon does (see below). Qi’s CLI and launch config will also handle core env like PATH, etc. The Qi Q\&A plan explicitly mentions the need to compute environments for launching DCCs once context (project, asset, task, app) is known (Ayon has a command for extracting context-specific env, which Qi might emulate).

* **Ayon environment setup:** Ayon-core provides a robust mechanism for environment preparation. After loading addons, it calls `AddonsManager.collect_global_environments()` to gather any environment variables that each addon wants to globally set. Ayon ensures these are merged with the current environment and applied (so that, for example, if an addon needs `MAYA_MODULE_PATH` or `NUKE_PATH` set, it’s in the environment before launching those apps). Furthermore, individual addons can fine-tune environment right when launching an application: the base `AYONAddon` class provides a hook `modify_application_launch_arguments(application, env)` where an addon can programmatically alter the env dict for that specific app launch (e.g. add specific variables or tweak paths). This is extremely useful for DCC integrations that need environment tweaks beyond static config. Ayon also implements **“dirmap”** functionality (in `ayon_core.host.dirmap`) to handle path translation between operating systems, enabling projects that span Windows/Linux/Mac to map file paths on the fly – an advanced feature Qi might consider down the road for cross-site workflows.

**Similarities and Differences:** Both Qi and Ayon see *bundles* as the unit of pipeline versioning and reproducibility. Qi is in the process of building this feature, likely inspired by Ayon/OpenPype’s proven pattern. One difference is that Qi, at least initially, might manage bundles locally or via the tracker (e.g., an Ftrack project attribute to pick bundle) whereas Ayon has a dedicated server controlling bundles. Long-term, Qi might also benefit from a central service to manage bundle definitions, especially if multiple users or teams use Qi – otherwise keeping bundle config in sync could be challenging.

In terms of environment handling, Ayon’s implementation is a great blueprint: Qi could implement an **addon method for global env vars** (similar to `AYONAddon.get_global_environments()` which returns a dict of env vars for that addon). Qi currently plans to use the BundleManager for envs, but leveraging each addon’s knowledge (e.g., a Maya addon knows which env vars Maya needs for integrations) would improve modularity. Qi’s messaging hub also opens the door to dynamically requesting environment prep (like asking each addon via an event to contribute env vars when launching something).

**Actionable ideas for Qi:** Use a formal **bundle manifest** (perhaps the `addon.toml` mentioned in Qi’s spec) to list addon versions and required env vars for that bundle. Ayon’s server essentially produces such a manifest for the client. Qi could adopt a lightweight manifest file or JSON for bundles, which could later be produced by a server or edited by hand. For environment management, Qi should implement a merging strategy like Ayon’s: gather env vars from all addons (ensuring no conflicts) and overlay them on the system environment at launch. Also, Qi might integrate a path mapping (DirMap) feature to facilitate multi-OS or remote scenario – this isn’t urgent for an MVP but is crucial for “cross-platform DCC orchestration” in the long run.

## DCC Integration (Host Addons and Processes)

A core purpose of both Qi and Ayon is to integrate with various DCC (Digital Content Creation) applications (Maya, Nuke, Blender, etc.). They both do this via **host-specific addons** that encapsulate all logic for a given DCC.

**Qi’s DCC Integration Approach:** In Qi, an addon can act as a **host addon** – meaning it knows how to launch and communicate with a particular DCC. A host addon is responsible for setting up the application’s environment, starting the process, and injecting any required scripts or plugins into the DCC. Qi’s design treats launching a DCC as spawning a *child session* in the Hub: the QiHub’s ConnectionManager will maintain a parent-child relationship between the main app and any launched DCC sessions. Concretely, when a user in Qi’s UI chooses to open a DCC (say Maya), the host addon for Maya will prepare the environment (e.g. assemble environment variables, set `PYTHONPATH` to include Qi and addon libs), then launch Maya – typically via the QiLauncher CLI or a system call. That DCC, on startup, will run initialization scripts (installed by Qi’s environment setup) that connect it back to Qi (for example, by opening a WebSocket to the QiHub). Qi’s Hub is built to handle multiple connections and route messages appropriately. The Qi spec indicates that only certain events (like opening or closing a window) go through the Hub, whereas high-frequency UI interactions within a DCC might be handled locally to avoid network overhead. Once the DCC is up, the host addon can also register **menu actions or commands inside the DCC** (e.g., adding a “Publish” menu in Maya that triggers Qi’s publish). This is facilitated by Qi’s plugin system: the host addon will load any *in-host plugins* (scripts that actually run inside Maya, often delivered via the addon’s `lib/` or `host/` directory) and ensure they are executed at the right time. Qi’s addon structure explicitly has a `host/` directory for code meant to run inside the DCC process. The communication between the DCC and Qi is likely through the WebSocket hub or possibly through a combination of Pyblish (for collecting results). The Qi architecture blueprint even envisions a **“Host Process Proof-of-Concept”** as a later phase, indicating this area is still being fleshed out.

To manage DCC processes, Qi will have a **SessionManager** (embedded in QiHub) to track child processes and ensure proper teardown on exit. Qi also plans an `on_close()` hook in addons for when the app is shutting down, which host addons can use to cleanly disconnect or save state from any open DCCs.

**Ayon’s DCC Integration Approach:** Ayon-core similarly uses addons for each DCC (Maya, Nuke, Houdini, etc.). Initially, in OpenPype, these integrations were part of the main codebase; Ayon is moving them into separate addon packages. Each **host addon** in Ayon implements the interface `IHostAddon`, indicating it “contains a host implementation”. The addon will declare a `host_name` (e.g. `"maya"`) and possibly the file extensions for that host’s scene files (for workfile management). When Ayon’s launcher wants to start a DCC, it uses a central **Applications addon** that defines application launch commands (this was present in OpenPype). Ayon’s `applications` addon likely provides a CLI or API to launch a given app in a given project context. Before launching, Ayon-core ensures all addons are “process-ready” via `ensure_addons_are_process_ready()`. This calls each addon’s `ensure_is_process_ready()` method, which host addons or auth addons can override to do things like prompt the user to log in if needed, or set up context. For example, if trying to launch Maya but the user isn’t logged in to the project management, the Auth addon might pop up a login dialog at that moment. This step prevents launching DCCs into an invalid state.

When launching the DCC, Ayon assembles the environment: it merges global env from addons, plus any context-specific env (project-specific or app-specific from its settings). It also may generate a temporary script to run on startup of the DCC. For instance, for Maya, Ayon sets environment variables like `MAYA_SCRIPT_PATH` to point to its startup scripts, which will execute and call back to the Ayon Tray (possibly via an RPC or by registering with a local socket server). Ayon doesn’t use a persistent bidirectional WebSocket for in-DCC communication (at least OpenPype didn’t); instead, much of the communication was one-time: e.g., when you hit “Publish” in Maya, it ran Pyblish locally and sent results to the Tray for display. However, Ayon could be evolving this – the presence of a “WebSocket /wss” endpoint in Qi is analogous to Ayon possibly adopting a WebSocket for live communication with the server (though not necessarily between tray and DCC).

Ayon also keeps the addon object for the host alive in the tray process. When the DCC starts, it will call back into Ayon-core to indicate it’s “installed.” The `AYONAddon.on_host_install()` hook is invoked at that time. This allows the addon to, for example, register event callbacks or syncing mechanisms while the DCC session is open. Essentially, once Maya is running with Ayon’s integration, the Maya addon’s code both lives inside Maya (for native API calls) and in the tray (for overseeing). They communicate perhaps through a shared REST API (OpenPype had an event server running on the tray that hosts would POST to). The specifics in Ayon-core might differ, but clearly the host addon is the orchestrator.

**Extensibility for DCCs:** Qi and Ayon both allow host addons to contribute DCC-specific **menu actions, load/save logic, and event hooks**. Qi lists that addons can extend DCC file handling (load, save, versioning) and provide custom *actions* in either the tracker or internal UIs. In Ayon, these correspond to loader plugins, create plugins, and actions that each host addon supplies via its plugin paths.

**Cross-platform orchestration:** Ayon’s matured pipeline handles scenarios like launching apps on farm machines, running headless processes, etc., through its CLI and remote publishing tools. Qi is targeting similar orchestration (the goals mention submitting renders to Deadline, etc.). Achieving that will require Qi to implement a robust host-launch abstraction – one that can perhaps launch not just locally but also package up environment and script for remote execution (similar to Ayon’s approach of extracting environments to JSON for farm jobs).

**Takeaways for Qi:** Ayon-core demonstrates the importance of a **dedicated application launch service** (in Ayon it’s part of the core/tray) that knows how to prepare each DCC. Qi might consider creating a specialized *Applications service* or making the host addons register their application launch commands to a central registry. This way, Qi could support commands like `qi launch maya --project PRJ --asset SH001` easily, leveraging addon-provided launch configs. Additionally, Qi can draw on Ayon’s pattern of injecting startup scripts: Qi’s host addons might include templates for each DCC’s startup to auto-connect to Qi’s hub. Qi already includes a Tray (with PyStray) and could allow host addons to augment the tray menu (Ayon’s ITrayAddon interface formalizes this – Qi could do similarly or just via addon API). Finally, for maintainability, Qi should treat each DCC integration as a separate plugin package as Ayon does. This ensures that adding support for a new DCC or updating one (e.g. Maya 2025 vs 2024 differences) is isolated. The Qi addon structure is already set up for this (each host in its own addon). Over time, Qi may even separate these host addons into their own repos or distributions, as Ayon has done by packaging them into zip releases. This modularity keeps the core clean and lets specialists work on specific DCC integrations.

## IPC and Messaging Patterns

A major architectural divergence is in how Qi and Ayon handle internal communication and external API access.

**Qi’s IPC via WebSockets:** Qi employs a **central WebSocket-based message bus** (`QiHub` and `QiMessageBus`) for communication between its components, UIs, and addon logic. The QiHub functions as a publish/subscribe and request/reply broker: UIs (which are essentially web frontends running in PyWebView) send messages over the WebSocket to the backend, targeting specific topics or commands. Addons on the backend register handlers for those message topics during their `register()` phase. For example, a Loader addon might register a handler for topic `"asset.load"` so that when the user clicks a “Load Asset” button (which triggers a WS message), the addon’s handler is invoked to perform the load. Qi’s bus supports not only one-to-one RPC (request/response) but also broadcast events. The Qi spec delineates a set of core topics like `auth.login`, `config.get`, `window.open`, etc. that are handled over the bus. The rationale is to minimize REST API surface and use a real-time channel for almost everything. In fact, one of Qi’s key decisions is that **aside from settings and bundle endpoints, all interactions go through the WebSocket hub**. This real-time messaging is well-suited for the interactive nature of Qi: UI actions propagate instantly, and multiple subsystems can subscribe to events. It also simplifies extending functionality – addons just hook into the bus rather than exposing their own APIs or relying on Qt signals.

Furthermore, Qi’s hub architecture naturally handles multiple sessions (the main app + child DCCs). Each session (connection) gets an ID and parent relationship; the hub can route messages to a specific session (e.g., send a command to only one DCC’s connection). This is powerful for orchestrating asynchronous tasks and will help if Qi implements features like live sync or collaborative sessions.

**Ayon’s Communication Pattern:** Ayon-core doesn’t use a unified internal message bus (at least not publicly documented). Instead, it relies on a mix of direct function calls, Qt signals, and interactions with the AYON server. For in-process communication (within the tray app), Python method calls suffice (e.g., one addon can call another’s method via the `AddonsManager` if needed, or emit a Qt signal). For communication **between processes** (tray ↔ DCC), OpenPype used to open an XML-RPC server in the tray or use Pyblish’s callback mechanisms. Ayon-core may refine this, but there’s no indication of a general pubsub bus akin to Qi’s. One reason is that Ayon’s UI is not web-based; it’s a Qt application running in the same process as the core, so it can call directly into Python functions. Qi’s web UIs, by contrast, run in separate JavaScript contexts, necessitating a message channel.

Where Ayon does use messaging is between **client and server**: the AYON server provides a real-time API via GraphQL subscriptions or possibly WebSockets for specific updates (for example, notifying the client of changes). The `ayon-python-api` client library primarily uses REST and GraphQL queries to talk to the server, and at least currently, it notes “Missing Websockets connection” in the TODO, suggesting that at 2025 Ayon may not yet have a client WS for server push events. In practice, Ayon might not need many push events because each user’s tray is mostly autonomous except when editing shared data (in which case the server acts as arbiter via API).

**Internal vs External API:** Qi’s approach is to handle internal interactions via WebSocket and to keep the **external API surface minimal** (only what’s needed for integration with external tools, like a `/publish` route or settings endpoints). Ayon’s approach is almost opposite: internal (client UI ↔ logic) doesn’t require a network interface since it’s in one app, but external interactions (client ↔ server, or tray ↔ headless farm machine) are via HTTP/GraphQL. Ayon-core even includes a CLI for headless publish, etc., which Qi also plans to have.

**Benefits and Drawbacks:** Qi’s WebSocket hub is a clear win for decoupling frontends and backends – it’s akin to a mini service bus within the app. This could allow, for instance, swapping out the UI (say to a different framework) without changing backend logic, or running multiple UIs (imagine a web dashboard controlling Qi remotely if the WS was exposed). Ayon’s tighter coupling of UI and logic through Qt means less overhead (no serialization of messages) and using tried-and-true Qt event loops, but it’s less flexible for modern web UI integration.

For long-term maintainability, Qi’s model could scale better: adding a new feature means defining a new message topic and handler, rather than wiring through multiple layers of UI code. It also encourages a clear separation of concerns (UI just emits intents via the bus, logic in addons does the rest). Ayon-core might have to gradually adopt more of this pattern as they move to a more distributed architecture (for example, if they integrate a web GUI or if multiple processes need to coordinate).

**Suggestion:** Qi should continue leveraging the Hub pattern and possibly expand it to cover **DCC ↔ main app communication** more fully. For example, Qi could run a lightweight WebSocket client within each DCC (Python can connect to the QiHub from inside Maya, etc.) to send events (like “publish finished” or “scene opened”) back to Qi, rather than relying on file polling or REST. This would effectively network all parts of Qi. Ayon likely doesn’t do this yet (though it might in the future with AYON server subscription feeds). By being designed in 2025, Qi has the chance to leapfrog here, creating a truly event-driven pipeline tool.

One caution: Qi must handle concurrency and threading carefully with the WebSocket approach (ensuring thread-safe calls, not blocking the event loop, etc.). Ayon’s simpler single-threaded UI approach avoids some complexity, but Qi can manage it with async patterns (FastAPI and websockets are async by nature). The payoff is worth it in agility.

## CLI and Automation Integration

**Command-Line Interface (CLI):** Both Qi and Ayon-core recognize the need for a CLI to run pipeline actions headlessly or automate tasks.

**Ayon’s CLI:** Ayon provides a robust CLI (based on `click`) under the `ayon` command. This CLI not only launches the tray (GUI) by default, but also has subcommands for various operations. Importantly, Ayon’s design allows **addons to contribute their own CLI subcommands** dynamically. In the CLI implementation, after initializing addons, Ayon iterates through each addon and calls its `cli(addon_cli_group)` method, passing in a click command group object where the addon can attach commands. For example, the “assets” or “maya” addon could add a command like `ayon addon maya launch…` or `ayon addon applications extractenvironments…`. In fact, we see that the CLI defines an `addon` group as a placeholder, and then `_add_addons()` populates it. The `AYONAddon.cli()` base method is meant to be overridden; Ayon’s docs show an example where an addon defines a click subcommand group and adds it. This results in a CLI where typing `ayon addon <addon_name> <command>` invokes the respective addon’s function. Additionally, Ayon-core has some built-in commands: e.g., `ayon publish <path>` to run headless publishing given a context JSON, or `ayon extractenvironments` to dump env vars for a context (though that one is marked deprecated in favor of an addon command). They also have convenience commands like `ayon contextselection` to open a GUI dialog for context, and `ayon run <script>` to execute a script in the Ayon environment.

This CLI infrastructure is quite comprehensive and shows how pipeline tools often need both GUI and headless modes seamlessly. It also aids in integration with continuous integration or farm processes (e.g., running `ayon publish` on a render node after rendering).

**Qi’s CLI plans:** Qi is still implementing its CLI capabilities. The architecture blueprint notes that the CLI (`QiCliManager`) is a stub and not in the MVP scope yet. However, Qi’s addon spec clearly includes the ability for addons to extend CLI commands. Likely, Qi will follow a similar pattern to Ayon: using a library like Click or Typer, Qi can define a base command (`qi`), with subcommands possibly grouped by addon or function. Addons would register their CLI verbs during their `register()` phase, probably by calling a method on `QiCliManager`. Indeed, Qi’s `QiAddonBase.register()` documentation mentions adding CLI verbs to the registry. The QiAddonManager code confirms this: during Phase 2 addon load, after calling `addon.register()`, Qi enqueues any CLI commands that the addon defined into a list, which will later be integrated into the CLI interface. We can anticipate Qi providing commands akin to Ayon’s (e.g., `qi launch`, `qi publish`, etc.), and allowing something like `qi <addon> <action>` for addon-specific tools.

The difference for Qi is that since Qi uses an embedded FastAPI server, some command-line tasks could also be invoked via HTTP if Qi is running as a service. But having a CLI is important for scripting and debugging outside the GUI. Qi will need to parse its own config (from .env or flags) in CLI mode – QiLaunchConfig already handles reading CLI args vs env for startup.

**Extensibility & Ergonomics:** The ability to plug in CLI commands means developers can create powerful automation without altering the core application. For example, an addon for asset batch processing could add `qi addon batchprocess run --project X`. Ayon’s approach to dynamically load CLI commands at runtime (rather than compile them in) mirrors its general extensibility philosophy. Qi will benefit from doing the same. One improvement Qi might consider is using a structured CLI library like **Typer** (which is built on Click but with Python function type hint introspection) to reduce boilerplate when adding commands. Ayon’s approach works but requires carefully constructing click commands inside each addon’s `cli()`.

**Suggestion:** Qi should ensure that the CLI loads addons in a lightweight way – possibly without bringing up the full GUI or server if not needed – so that running a headless command is fast and doesn’t require the whole application to initialize (Ayon does this by detecting headless mode and not starting the tray UI unless needed). Qi can emulate Ayon’s pattern of injecting addon commands into a main `addon` group, or even allow top-level commands if an addon wants to register one. For maintainability, documenting the CLI and encouraging usage for batch tasks will make Qi more versatile (much like Ayon is used both by artists via GUI and by TDs via CLI on the farm).

## API Strategy: REST vs WebSockets

We touched on this earlier in IPC, but to summarize explicitly:

* **Qi’s API Strategy:** Qi opts to use **WebSocket (WS)** for the bulk of its internal API. The FastAPI REST endpoints it exposes are intentionally minimal – primarily for configuration (settings and bundles) and for serving static files (the web UI content). All interactive operations, from user commands to addon actions, flow through the WebSocket hub. Qi does not currently expose a large REST API for external consumption; instead, external scripts would likely use the CLI or could potentially connect to the WS (if authorized). This design choice reduces duplication (no need to implement a function in both a REST handler and a WS handler) and leverages persistent connections for stateful interaction. It’s very much aligned with real-time apps.

* **Ayon-core’s API Strategy:** Ayon-core itself doesn’t serve an HTTP API (that’s the role of the AYON server). For external communication, Ayon relies on the server’s REST/GraphQL endpoints for things like querying projects, updating data, etc.. The Ayon-core client includes the `ayon-python-api` to talk to these endpoints. Internally, Ayon doesn’t use WebSockets for UI logic as discussed. So in essence, Ayon uses **REST/GraphQL for client-server** and **function calls/Qt signals for in-app**. One might say Ayon’s “API” surface is the AYON server API plus the command-line interface for automation tasks.

The difference is clear: Qi is somewhat “serverless” (no central server component for pipeline data yet, aside from linking to Ftrack eventually), so Qi’s own app must handle API-like duties – hence the built-in WS and small REST API. Ayon has a heavy server, so the client can stay lean and delegate all persistent data queries to the server’s API.

One interesting note: Qi’s approach could allow, in the future, exposing certain WebSocket topics or HTTP endpoints for integration with other tools (for example, a remote trigger to start a publish via an HTTP call to Qi, or a WS connection for a live monitoring UI). Ayon instead would make those integrations go through the AYON server (which might have a REST endpoint to trigger a publish on a specific workstation, etc.). Neither approach is inherently better – they reflect different product philosophies (Qi as a desktop app that might operate standalone vs Ayon as a client-server system requiring network infrastructure).

**Security and Networking:** Qi’s local REST/WS is meant for local use (bound to localhost with auth token), whereas Ayon’s server API is network-accessible and token-protected at a higher stakes level. Qi will be running both a client and an embedded server on the user’s machine, which simplifies not having to worry about multi-user concurrency on those APIs. Ayon’s server must handle multiple users, projects, etc., so its API strategy is necessarily more complex (including GraphQL for flexibility).

**Actionable thought:** If Qi ever introduces its own central server (for multi-site usage or replacing the dependency on external trackers), it might adopt a similar pattern to Ayon: a robust REST/GraphQL API on the server and a lighter client. But until then, Qi’s WS-heavy design is appropriate. Qi should, however, document the WebSocket API clearly, as it effectively becomes an internal protocol. As the team grows or third-party devs write addons, understanding the bus topics and payloads (as Qi’s reference table outlines) will be important. Ayon’s use of standard HTTP APIs makes it easy for others to interact with the server; Qi might consider providing a small library or at least examples for interacting with the Qi WS from an external script (for example, how to programmatically trigger something via the WS without the GUI – or rely on CLI for that).

In summary, Qi is **WS-first, REST-second**, whereas Ayon-core (client) is essentially **REST-client, no internal WS**. This is a notable technical difference that influences development: Qi developers must think in terms of asynchronous message passing, which is a bit more complex than the synchronous function calls Ayon devs might be used to, but it yields a very dynamic system.

## Lessons from Ayon-Core for Qi’s Future

Finally, comparing these two systems highlights some advanced features in Ayon-core that Qi could strategically adopt to enhance maintainability and developer ergonomics – **without simply copying code**, but by learning from proven patterns:

* **Structured Addon Packaging and Manifest**: Ayon-core treats each addon as a versioned, self-contained package (usually a zip or directory named `<name>_<version>` with all its code). Addons have clear metadata like name and version (enforced by class properties). Qi should implement a similar manifest for addons – e.g., an `addon.toml` file in each addon (as mentioned in Qi spec) to declare the addon’s name, version, and even dependencies. This manifest could list Qi’s minimum core version required, and other addon inter-dependencies. Having a structured manifest will help Qi in **dependency resolution**: if addon A requires addon B, Qi can check the manifest and auto-load B or warn if missing. Ayon currently avoids conflicting dependencies by using the bundle to pick exact versions; Qi’s addon.toml could facilitate a lightweight check (and later, if Qi allows optional addons, it can skip or fetch them on the fly). Also, by packaging addons (potentially as zip distributions or pip-installable packages), Qi can allow easier upgrades and a plugin ecosystem. Ayon’s team explicitly moved toward splitting addons into separate repos and automating the creation of zip packages – Qi might not need separate repos yet, but designing for that possibility (so that an addon’s code is not tightly entangled with core code) is wise.

* **Hot-Reloading and Dev Mode**: As noted, Ayon has a developer mode where an addon can be loaded from a custom path for a specific user. This allows a developer to work on, say, the Maya addon on their machine using an editable source directory, while others use the stable zip. Qi could emulate this by allowing an override in config (or environment variable) to load an addon from a given filesystem path (during development) instead of from the bundled location. This drastically improves dev ergonomics: you don’t have to rebuild or restart the entire app with a new install for every code change. Qi’s dynamic import system is already in place; adding a check for a “dev addons” mapping (like Ayon’s `addonDevelopment` in bundle info) would be valuable. For hot-reloading within a session (i.e., reload addon without restarting Qi), that’s trickier in Python, but Qi’s architecture *could* allow unloading and reloading an addon if designed carefully (though not a priority for MVP, it’s something Ayon doesn’t do yet either, aside from restarting the tray).

* **Better Plugin Encapsulation**: Ayon-core’s approach to plugins – especially how each addon explicitly provides plugin directories via `IPluginPaths` – ensures that adding or removing plugins doesn’t require changing core logic. Qi can adopt a hybrid approach: continue using class-based plugins, but also possibly allow addons to declare plugin search paths for tools like Pyblish, so that external plugins (not implemented as QiPluginBase) can still be integrated. For example, if a studio already has a suite of Pyblish plugins in a folder, Qi could just accept a path to them via settings, without wrapping each in QiPluginBase. This flexibility would make Qi more adoptable. In general, Qi’s plugin base classes are good for new development, but **being permissive in integrating legacy plugins** (by discovering by path) could broaden Qi’s utility.

* **Interfaces and Mixin Patterns**: Ayon uses interface mixins (`ITrayAddon`, `IHostAddon`, etc.) to organize addon capabilities. Qi currently uses a simpler “role” attribute for core providers, but it could benefit from adopting interface-like concepts for other concerns. For instance, Qi might introduce a base class or marker for “Host addons” that require a `host_name` property and perhaps implement methods like `launch()` or `get_launch_args()`. This would standardize how Qi deals with host addons, making the code clearer and reducing duplication between, say, a Maya addon and a Nuke addon. Similarly, a “Tray addon” interface (for addons that add tray menu entries or background services) could formalize how tray icon interactions are added. Qi already has the idea of addons extending the tray menu; providing a small abstract class or even just documentation guidelines (like “if your addon has UI elements, implement a method `build_tray_menu(QiTrayManager)`”) can help maintain consistency. While Python doesn’t have true interface enforcement, Qi can simply check for expected attributes or use ABCs like Ayon does.

* **Cross-Platform Considerations**: Ayon’s inclusion of features like path mapping (DirMap) and site synchronization for remote file access came from real-world pain points. Qi should keep these in mind as future improvements. For example, **path mapping**: if Qi will be used across different OS or in cloud VMs, allowing a mapping table (like Windows “X:\share” → Linux “/mnt/share”) is extremely useful so that published file paths can be translated. This could be an advanced addon or part of core (Ayon puts it in core, `ayon_core.host.dirmap` presumably). Another is handling remote execution: Ayon can package environment contexts to JSON for farm jobs – Qi could implement a similar `qi bundle export-env --project X --app maya > env.json` and a way to consume that on a render node to run headless operations with the correct environment.

* **Stability and Hardening**: Ayon’s longevity means it has accrued many checks and fallbacks. Qi can inspect Ayon-core’s error handling to anticipate issues. For instance, Ayon logs a warning if an addon class is abstract or missing implementation, skipping it – Qi might incorporate a similar warning if an addon doesn’t fully implement required methods. Ayon also catches exceptions during addon init and continues loading others, whereas Qi currently might raise and stop on any addon load failure (except it does catch non-provider errors). Depending on Qi’s use case, continuing to load other addons when one fails (isolating the failure) could improve robustness in production.

* **Use of a Backend**: While outside the scope of comparing Qi vs Ayon-core (since Ayon’s backend is separate), it’s clear that having a central server provides Ayon some advantages (single point for settings, bundle config, and multi-user data). If Qi remains a purely client-side application, it should plan for how multiple users collaborate or share data. Possibly Qi will rely on the production tracker (like Ftrack) as the pseudo-backend. If Ftrack is used, Qi might develop an Ftrack addon that pulls settings/bundles info from Ftrack’s database (perhaps via custom attributes or the API). This would mimic Ayon’s server role. Therefore, **the suggestion** is for Qi to design its data models (for settings, bundles, etc.) in a backend-agnostic way so that switching to a dedicated Qi server or integrating with different trackers is feasible. In other words, keep using the `QiDbManager` abstraction as planned, so that today it reads local JSON, tomorrow it could read from an HTTP API without changing higher-level code.

In conclusion, Qi and Ayon-core share the vision of a pluggable, extensible pipeline toolset. Ayon’s solutions to common pipeline challenges – managing many addons, ensuring one source of truth for configs, gracefully handling multiple DCCs – are battle-tested. Qi can **draw inspiration from these patterns** to refine its own architecture:

* Embrace explicit addon packaging and versioning to ease updates (perhaps publish Qi addons on PyPI or as zip bundles).
* Provide developer shortcuts for iterative addon development (configurable addon paths, quick reloads).
* Maintain a lean core by pushing DCC-specifics to addons (Qi is doing this; keep that course).
* Use interfaces or at least documented patterns to standardize addon behaviors (host, tray, provider, etc.), which makes the system more predictable.
* Plan for cross-platform and multi-context use early (even if Qi’s first release is single-site, knowing what’s next helps avoid refactoring later).

By implementing these ideas, Qi can improve its long-term maintainability and developer ergonomics, and gradually evolve into a **comprehensive pipeline framework** that stands on the shoulders of giants like Ayon/OpenPype, while still innovating with its unique web-first, hub-driven approach. Each enhancement should be done in Qi’s style (for instance, Qi might use modern libraries or patterns where Ayon uses legacy ones), but the underlying lessons are incredibly valuable. With thoughtful integration of these concepts, Qi could achieve a level of maturity and flexibility comparable to Ayon in a shorter time, all while preserving its distinct architecture tailored for cross-application orchestration.

**References:**

* Qi Project Specifications and Roadmap
* Qi Developer Q\&A and Planning Docs
* Qi Addon/Plugin Architecture (source code)
* Ayon-Core README and Documentation
* Ayon-Core Source Code (Addons and Interfaces)
* Ayon-Python-API README (client-server communication)


# Next Steps and Development Roadmap for Qi

## Finalize and Harden the Core Framework

The first priority is to complete all remaining core subsystems and solidify Qi’s foundation before moving to any new features or add-ons. Key tasks include:

* **Implement Persistent Data Services:** Introduce the **QiDbManager** as a core service with pluggable adapters (e.g. a local FileDB adapter for settings, and a mock Auth adapter for user/project data). This provides a central API for persistence (user settings, bundle definitions, etc.) and will allow swapping in real backends later (e.g. a Ftrack adapter in the future).

* **Centralize Configuration Management:** Build the **QiSettingsManager** to orchestrate application and add-on settings. It should load default settings (using the existing `QiSettings` schema), apply any saved overrides (from QiDbManager’s storage), and expose get/set operations. This manager will also back new REST APIs (e.g. `GET /settings` and `PATCH /settings/{addon}`) and a message-bus topic for configuration changes, enabling the UI and other components to retrieve and update settings centrally.

* **Complete the Add-on System:** Finalize the **QiAddonBase** class and **QiAddonManager** to handle plugin/add-on loading in two phases. In Phase 1 (bootstrapping) core providers like Auth and DB are loaded first; in Phase 2, all other addons load once a user is authenticated and a bundle is selected. The manager should enforce **role guards** (exactly one “auth” provider and one “db” provider must be present, otherwise abort). This ensures the core has the necessary providers and prevents conflicts. The Addon system will also register each add-on’s UI routes or message handlers as needed during loading.

* **Introduce Bundle Management:** Develop a simple **QiBundleManager** to define and switch between environment “bundles” (e.g. a production vs. staging configuration). Initially, this can be a basic list of bundles defined in config or a file, with one active bundle at a time. The manager should provide an API (and a `PUT /bundles/active` endpoint) to switch the active bundle, which will later allow different sets of add-ons or settings per context. This lays groundwork for per-project or per-show configurations without hard-coding them into the core.

* **Integrate Auth and Project Context (MVP):** As part of finalizing the core, implement a **mock Auth provider addon** and tie it into the system. This addon will supply a dummy login mechanism (e.g. always succeed with a test user) and a token storage, simulating user authentication. It should provide at least one UI flow (like a login dialog) and respond to an `auth.login` bus request. This allows testing the end-to-end startup: Qi can launch, prompt “login”, then proceed once the user is “authenticated.” Later, this addon can be replaced or augmented with a real Ftrack-auth integration, but for now it ensures the authentication flow and session token handling are in place. Similarly, ensure the **FileDB adapter** in QiDbManager can return basic project data (or dummy data) so that core features expecting project lists or other info have something to work with.

* **Finalize Plugin Loading and Publishing:** Extend the **QiPluginBase** (and plugin discovery mechanism) so that add-ons can include pipeline plugins (like Pyblish plugins for publishing). The goal for MVP is to support a basic **“Publish”** operation: Qi should discover any publish plugins provided by addons, register them with Pyblish, and trigger a headless publish run when the user requests it. This involves writing a simple **Publish Addon** that defines a Pyblish plug-in or two (or a dummy plugin for test) and adding a UI button or command to initiate publishing. By doing this, we ensure the pipeline workflow (one of Qi’s core purposes) is represented in the core framework. The publish process can be minimal to start – e.g. just logging that it ran – but the architecture (message bus event `publish.request`, plugin registration) should be in place.

By completing the above, the **core framework will have all essential pieces in place** – configuration persistence, add-on loading, bundle selection, auth, and a basic publish mechanism – without yet diving into domain-specific customizations. This satisfies the immediate goal of *finalizing the core*, after which we plan to avoid major expansions to core functionality unless absolutely necessary for unforeseen features.

## Focus on Core Stability and Polish

With the core features implemented, the next focus is on **stability, polish, and consistency** of the core framework. This phase involves refining what’s already built rather than adding new capabilities:

* **Rigorous Testing & Validation:** Ensure all new components (DbManager, SettingsManager, Addon/Bundle managers, etc.) have thorough unit tests and integration tests, building on the fact that all existing tests are passing. The core should handle error cases gracefully (e.g. missing config files, failed addon load) and log useful information for debugging. By solidifying tests now, we create a safety net that will catch regressions in future addon development.

* **UI and UX Refinements:** Complete the integration of the GUI elements with the backend. For example, wire up the **QiWindowManager** fully so that the main UI window can open on launch (running the pywebview event loop), and implement message bus handlers for window operations (open/close) and a minimal system tray icon for convenient control. These tasks (outlined as Phase 5 in the roadmap) ensure the application feels cohesive: the Command Center window opens as expected, windows can be closed properly via UI actions, and a tray icon allows the user to show/hide or exit the app gracefully. While these are polish items, they contribute to a stable user experience.

* **Performance and Robustness:** Profile and optimize any slow startup or runtime operations if needed (though at this stage the app is lightweight). Also, implement **graceful shutdown** procedures (e.g. ensuring all child processes or threads are closed, saving state if needed). The core should be resilient: if an addon fails, it should not crash the whole app; if the user quits, the shutdown should not corrupt data or leave processes hanging.

* **Security and Hardening:** Even for an MVP, consider basic security measures. For example, if using WebSocket or REST, ensure that an **authenticated token** (even the dummy one) is required for sensitive operations. The roadmap mentions migrating to JWT auth for production – that can be planned for later, but the design should allow plugging in such auth easily. Also, restrict the REST API surface: as decided, keep it limited to settings and bundle management initially to reduce exposure. All other interactions (like controlling windows or triggering publishes) go through the WebSocket bus, which is only accessible to the local UI clients.

* **Documentation and Developer Support:** As the core stabilizes, prepare comprehensive **developer documentation** for the system. This includes documenting how to write an addon (using QiAddonBase), how to define settings, how the message bus topics work, and how to run and configure Qi. Good docs will make it easier to write the specialized addons in the next phase without needing to change core. Additionally, set up basic **CI pipelines** to run tests on new changes (to catch issues early), and possibly package the application for testers. Polishing these aspects will mark the core framework as truly production-ready.

* **Freeze Core Feature Set:** Perhaps most importantly, treat this as the final chance to make any necessary core changes. After this polishing phase, **avoid extending the core further** – it should remain stable, with future work happening in addons or minor tweaks only. Further refactoring or new core features should happen only if absolutely required for a critical new use-case. By solidifying the architecture now (and resolving any architectural debt), we ensure that subsequent development on Qi (add-ons, tools, etc.) can proceed without constantly revisiting core modules.

By the end of this stability and polish pass, Qi’s core should be **robust, well-tested, and feature-complete** (for the intended MVP scope). This forms a reliable platform on which user-facing features and specialized integrations can be built with confidence.

## Command Center – The Primary User Interface

The **Command Center** will be the only major user-facing tool in the initial release of Qi’s MVP, serving as a centralized frontend for configuration and management. The development steps for the Command Center include:

* **Settings Management UI:** The Command Center will primarily function as a **settings editor and dashboard**, much like the settings interface in Ayon Server. It will use the new settings APIs (e.g. **`GET /settings`** to load current configuration, and **`PATCH /settings/{addon}`** to apply changes) to let users view and modify settings in a user-friendly way. Each add-on’s settings (as defined in its schema) should be presented, likely grouped by addon or category, with default vs. overridden values clearly shown. When a user edits a setting, the UI will call the PATCH endpoint to save the override, which under the hood triggers QiSettingsManager to persist via QiDbManager. This ensures a seamless loop where changes in the UI update the backend and are reflected across the app (and on next startup).

* **Bundle Selection UI:** Include a section in the Command Center for managing **bundles**. Using the **`GET /bundles`** endpoint, the UI can list available bundles and show which one is active. The user should be able to switch the active bundle (e.g. via a dropdown or list selection); when this happens, the UI calls **`PUT /bundles/active`** with the chosen bundle. QiBundleManager will then update the active bundle and possibly reload certain add-ons or configurations accordingly. In the UI, this might trigger a prompt like “Restart required for changes to fully apply” if needed, or ideally a hot-reload of addon configurations if supported. This bundle management UI enables non-developers (or pipeline TDs) to easily swap contexts without editing config files manually.

* **Launching Actions from UI:** The Command Center can also serve as a hub for basic user actions. For MVP, this might mean providing simple buttons or menu options such as **“Open DCC Application”**, **“Run Publish”**, or **“Exit”**, as indicated in the architecture flow. For example, a dropdown of available DCC host tools can be shown (or just a generic “Launch Host” for now), which when clicked publishes a `window.open` event or calls a small API to have the Host Addon launch the DCC. Similarly, a **“Publish”** button in the UI can trigger the `publish.request` event to run the Pyblish workflow. These controls tie into the backend via the message bus (or minimal new REST calls) and allow the user to exercise core functionality from the Command Center. They will likely be simple in the first version (e.g. no complex dialogs, maybe just console output for results), but they prove that the end-to-end pipeline actions are accessible.

* **Integration with PyWebView:** The Command Center is essentially a web frontend loaded in a PyWebView window. Part of this task is ensuring that the **QiWindowManager** opens the Command Center on startup (after the backend is ready). We need to build or integrate a minimal HTML/JavaScript frontend that can call the Qi REST APIs and WebSocket (for bus messages) to perform the functions above. This could be a lightweight single-page app or even static HTML for now, generated from a template. The key is that when Qi starts, it spawns a window (through pywebview) pointing to (for example) `http://localhost:3000/command-center` or an embedded HTML file that represents the Command Center UI. The UI’s look and feel can be basic initially – focus on functionality (settings form, few buttons). We can iteratively enhance the UX once it’s working.

* **Minimal Tray Controls:** Alongside the window, implement a **system tray icon** with a context menu for convenience (this was mentioned as a polish item). For example, the tray menu might have options like “Show/Hide Command Center” and “Quit Qi”. This is especially useful when the Command Center window is closed or minimized – the app can keep running in the background, accessible via the tray. Using PyStray (as planned for QiTrayManager), implement this feature in a basic form for the MVP.

By focusing on the Command Center as the sole UI, we keep the user-facing surface minimal and manageable. Users (or pipeline engineers) will be able to configure Qi and trigger core actions through a single coherent interface. Importantly, **delaying other UIs** (like per-DCC tool GUIs or complex publishing wizards) avoids distracting from completion. Those can come later as needed. The Command Center provides enough UI to consider Qi usable (settings management, launching apps, running publishes), fulfilling the immediate requirements while the core is solidified.

## Specialized Add-Ons After Core Completion

Once the core framework is stable and the Command Center UI is in place, development focus will shift to building out specialized functionality as **add-ons** on top of Qi. This allows new features to be added without modifying core code, in line with the goal of keeping the core stable. Some high-priority add-on developments likely include:

* **Real Authentication & Project Integration:** Replace or extend the mock auth addon with a **production-ready Ftrack integration** (or any chosen studio authentication system). The architecture anticipated this, planning for the mock auth to eventually be swapped with an Ftrack-backed addon. This new auth addon would handle real user login (perhaps via Ftrack API or OAuth), fetch user-specific data like project lists or tasks, and supply those to Qi (e.g. populating project choices in the UI). Implementing this as an add-on means it can use QiDbManager’s interface or its own connections to communicate with the external system, and provide the token/session info back to Qi’s core (likely via QiHub messages or QiDbManager callbacks). This is a key step to make Qi viable in a production setting, connecting it to the studio’s actual data.

* **DCC Host Add-Ons:** With the core ready (and a Host Addon scaffold in place), we can create add-ons for each target DCC (Digital Content Creation) application. For example, an **Maya add-on** that knows how to launch Maya in the correct environment, or a **Nuke add-on** for Nuke, etc. These host add-ons would implement the logic to start the application (possibly via command line or an API), manage the “child” Qi session for that app, and load any app-specific plugins. In the MVP, a dummy host launch was considered a proof-of-concept; going forward, we’d flesh this out for real DCCs. Each host addon can also contribute UI elements or forms if needed (e.g. options before launching, or a way to choose a scene file). By modularizing each host as an addon, studios can include only the ones they need per bundle.

* **Additional Pipeline Plugins:** Beyond the basic publish flow, Qi can be extended with add-ons that provide **specialized pipeline steps**. For instance, an addon for asset creation might include plugins for generating new assets, or an addon for reviewing might integrate with a review platform’s API. These would leverage the QiPluginBase interface to register their plugins and possibly add new bus topics or REST endpoints if needed. Because the core now supports plugin discovery and execution, adding more plugins does not require core changes – just develop new add-on packages. A focus can be on a suite of Pyblish plugins for common VFX pipeline tasks (validation, farm submission, etc.), delivered as one or multiple add-ons. The Command Center (or other future UIs) could then expose these functionalities to users.

* **Enhanced UI Add-Ons:** Although initially we limit the UI to the Command Center, eventually we may create specialized UIs as add-ons. For example, a publishing GUI that guides the user through selecting files and writing metadata could be an addon with its own web UI, opened in another Qi window. Similarly, an asset browser or task manager UI could be separate addons. Thanks to Qi’s architecture, these would plug in via QiAddonManager and communicate over the hub. We mention this for completeness, but such UI-rich addons should only be tackled once the core is proven stable and simple add-ons (auth, host launchers, basic plugins) are out of the way.

In all cases, the guiding principle is to **develop these features as external add-ons** rather than core modifications. The core provides the hooks (via the addon system, settings, message bus, and REST where applicable), so new capabilities can be added cleanly. This modular approach means that after the core is finalized, Qi’s growth will come from a library of add-ons tailored to specific studio needs or pipeline functions, without needing to alter the core framework. It also makes maintenance easier – core updates will be rare and only for major new requirements, while most new code goes into versioned add-on packages.

## Re-Evaluating Priorities and Adjustments

Given the above roadmap and the emphasis on **core stability** before anything else, it’s important to periodically recheck priorities. The plan can be adjusted as needed to meet the goal of a solid core and a usable MVP:

* **No Strict Timeline, but Logical Sequence:** Since there is no hard deadline, focus on the logical order of development. It generally makes sense to follow the phase order outlined (foundation → addons system → basic providers → UI polish → etc.), as each step builds on the previous. However, we should remain flexible. If a later feature becomes a blocker for testing an earlier one, we might implement a stub of it sooner. For example, if testing the Command Center requires at least a minimal publish button, we might implement the publish trigger (Phase 4) in parallel with finishing settings (Phase 2). Overall, though, avoid jumping ahead unless necessary – completing the foundation first will prevent backtracking.

* **Deferring Non-Essential Features:** To concentrate on core hardening, some planned features can be postponed. For instance, the **CLI interface** is explicitly noted as out of MVP scope – it can be left until after the first release, since a GUI (Command Center) is handling interactions. Similarly, the **host process proof-of-concept** (Phase 6) is marked “if time”. We should not let it delay the MVP; it can be done later or skipped if real host launch add-ons will supersede it. By deferring these, we allocate more time to polish critical systems (settings, auth, publish) that directly impact users.

* **Addressing Unforeseen Needs:** As development progresses, if we discover a *major* missing piece in the core that was not anticipated (for example, a need for inter-add-on communication mechanism beyond the bus, or a new core service for scheduling tasks), we should evaluate it critically. Is it truly necessary for MVP or can it be worked around via an addon? Only if it’s fundamental and broadly needed should we extend the core. This careful approach aligns with the goal that **core refactoring/extension happens only for major, unplanned requirements**, not for minor conveniences. It’s better to ship a smaller, stable core and iterate via addons than to continuously expand the core.

* **Continuous Re-prioritization:** After each milestone (e.g. finishing the settings foundation, or getting the Command Center UI working), reassess what the next most important deliverable is. The guiding question should be “Does this next task bring us closer to a usable, stable MVP without introducing undue risk to the core stability?” If yes, proceed; if not, consider postponing it. For example, if after implementing the basics we find that a fancy UI feature would be nice but isn’t necessary, it can wait. On the other hand, if users testing the MVP say they need a particular add-on urgently, we might prioritize that add-on even if other add-ons were planned first.

By keeping an eye on priorities in this way, we ensure that development effort is always aligned with Qi’s immediate goals: **finalizing the core framework, delivering a polished MVP with the Command Center, and then moving into specialized extensions.** This flexible but focus-driven strategy will help avoid wasted effort and ensure Qi matures in a controlled, stable manner.

In summary, the roadmap for Qi’s next developments is clear: **finish and fortify the core**, deliver the minimal **Command Center** user interface for configuration, and then **expand outward with add-ons** for specific functionality. This approach maximizes stability and maintainability, setting Qi up for success as a pipeline platform. All core work is done with the intent that, once this phase is complete, the core will remain largely unchanged – allowing the team to concentrate on high-value features in addons going forward. The result will be a stable foundation (Qi Core 1.0) upon which a rich ecosystem of pipeline tools can be built without constantly reinventing the wheel.&#x20;
