# FIRST REPO SCAN + PLANNING

Plan for Next Steps in Qi Development
Current Status and Context
Qi is a VFX pipeline desktop application being built with Python and web technologies. The current codebase already has several core components in place:
Configuration: The QiSettings system (hierarchical settings built on Pydantic) is implemented and passing tests. The main launcher config (QiConfigManager) is working (reading .env and qi.config.toml for things like host, port, dev mode, etc.).
Messaging Hub/Bus: The WebSocket message bus (hub and core.messaging modules) is implemented and tested, enabling communication between frontend UIs and the backend.
FastAPI Server: A FastAPI server (core.server.server) serves the UI and websocket endpoint. It currently handles basic requests and the /ws endpoint for messaging.
Plugin Framework: There is a QiPluginBase abstract class defining how addons (plugins) should implement discovery, registration, and processing. Right now this base is very generic and minimal.
Window Manager: The QiWindowManager (using pywebview) can create and manage UI windows. It opens a new window for a given addon by loading the appropriate URL (pointing to the local server’s route for that addon) and keeps track of open windows. Basic open/close/list operations are in place.
All unit tests provided are passing, so the existing functionality is stable. With this foundation laid, the next step is to implement the higher-level managers and integrations that tie these pieces together into a fully functional application. Specifically, we need to focus on persistent data management (settings, bundles), extending the plugin system, enhancing the server with new REST APIs, and integrating window control with the message bus. Below is a detailed plan for moving forward, broken down into key components and their implementation steps.

### 1. Implement QiDbManager with Pluggable Adapters
Why: A central data access layer is needed to manage persistence and external data sources. The code references a QiDbManager facade that will abstract away different data backends (authentication, file storage, etc.). Without this, components like settings or bundle management can’t load/save data or interface with external systems (making them hard to test or use). What to do: Design and implement QiDbManager as a singleton or central class that provides a uniform API for data operations. Under the hood, it should delegate to adapters for specific domains, for example:
Auth Adapter: Handles user authentication and project data retrieval (likely via Ftrack’s API, since Ftrack is the VFX project management dependency). This adapter would include methods to log in, fetch user info, list projects/contexts, etc. Initially, this can be a stub or mock implementation (for testing) that returns dummy user data or simulates login success. In the future, it will integrate with Ftrack’s Python API.
FileDB Adapter: Handles local persistence (configuration files, local database, or simple JSON storage). This would be used for storing user-specific settings, bundle definitions, cached data, etc. For now, a simple approach could be reading/writing a JSON or TOML file on disk (e.g., a user settings file separate from the main qi.config.toml). Using an adapter pattern means we can later swap in a more robust solution (like an SQLite database or an API call) without changing the higher-level code.
Implementation details:
Define QiDbManager with methods like get_auth_adapter() and get_file_adapter() (or more abstract methods like login_user(...), load_settings(), save_settings(), etc., that internally call the appropriate adapter). Ensure that adapters can be easily injected or mocked in tests – e.g., via dependency injection or by setting the adapter instances on the manager.
For now, implement minimal stub logic: The Auth adapter can simply store a “logged_in” flag and return a dummy user/project list. The FileDB adapter can read/write to a local JSON file for settings. Make sure to handle error cases (file not found, etc.) gracefully, perhaps by initializing with defaults if no file exists.
Write basic unit tests for QiDbManager: e.g., a test that setting a test adapter and calling a method returns expected values. This ensures QiDbManager is working and can be used by other components.
By completing QiDbManager first, you establish the foundation for persistence and external data handling. This will unlock the next tasks (Settings and Bundle managers) and ensure those can be tested independently of actual external systems by swapping in test adapters.

### 2. Develop QiSettingsManager and QiBundleManager for Configuration
With QiDbManager in place, implement managers for Settings and Bundles – two crucial configuration domains in Qi.

#### 2.1 QiSettingsManager – Centralized Settings Handling
Role: QiSettingsManager will orchestrate application settings, using the hierarchical schema defined by QiSettings (which is already implemented as a QiGroup/QiProp system). This manager should load settings from persistent storage on startup and allow updates. Key responsibilities:
Load and Save Settings: On startup, QiSettingsManager should retrieve saved settings (if any) via QiDbManager’s file adapter. For example, it might load a JSON or TOML file that contains user overrides for the default settings schema. Use the QiSettings object to build the default schema (with all default values), then overlay any saved values. Similarly, when settings are changed (perhaps via a UI or CLI), QiSettingsManager should validate and save them back through QiDbManager.
Global and Addon Settings: Anticipate that each plugin/addon can have its own settings. The manager should handle both core settings (app-wide config) and addon-specific settings. One approach is to namespace settings by addon: e.g., have a top-level group in QiSettings for each addon’s config. QiSettingsManager can initialize by creating the global QiSettings object, then querying each plugin to incorporate its schema (see Plugin section below).
Access API: Provide methods for the rest of the app to get or set settings. For example, QiSettingsManager.get("some.path.in.settings") to retrieve a value, or methods to enable/disable features (which internally flip certain flags). This will centralize how other components (and the UI via API) interact with configuration.
Implementation steps:
Define the structure of the default settings. Likely, QiSettings is built by code (using the context-manager style as in tests) to include sections like features, auth, logging, etc. Ensure QiSettingsManager constructs this default when it’s created.
On manager init, call QiDbManager’s file adapter to load saved settings data (if a file exists). Merge those values into the QiSettings object (you might use Pydantic’s ability to load from dict, or manually assign QiProp values). If nothing is saved yet, the defaults remain.
Provide a method to persist settings: perhaps QiSettingsManager can be told when to save (e.g., after a user changes settings via the UI). It would take the current QiSettings state and write it out via QiDbManager.
Write tests for QiSettingsManager: Simulate a QiDbManager with a test adapter that returns a known settings dict; verify that QiSettingsManager loads it correctly and that saving writes expected data.

#### 2.2 QiBundleManager – Environment & Bundle Management
Role: QiBundleManager will manage “bundles,” which in the Qi context are sets of configuration for the working environment. Based on the project’s specifications, a bundle is likely a collection of addon versions and environment settings that can be tied to projects for reproducible setups (e.g., a production bundle vs. a staging bundle for testing new plugin versions). Key responsibilities:
Define Bundle Structure: Decide how to represent a bundle in code. For instance, a bundle might include a name (identifier), a set of addon version mappings, and perhaps environment variables or launch parameters for DCC applications. Since implementing full version management is complex, start simple: maybe a bundle is just a label with associated plugin configurations.
Load Available Bundles: QiBundleManager should load bundle definitions from a source. This could be a section of a config file (e.g., qi.config.toml might contain bundle info), or a separate bundles file, or even from Ftrack if bundle info is stored there. To keep things manageable, you could define bundles in a local file or in code for now. For example, initialize with two bundles: "default" (or "production") and "staging", as hinted in the spec. The staging bundle could use a different set of addon versions or settings to test new features.
Select Active Bundle: Provide a way to get/set the current active bundle. For example, if the user chooses a different bundle (perhaps via the UI), QiBundleManager should update an internal pointer to the active bundle and possibly trigger changes in the environment. This could involve reloading certain addons with different versions or toggling features. For now, simply storing the active bundle name is enough, but design the interface for potential future expansion.
Integration with Addons: Later, addons might need to know which bundle is active (to pick appropriate plugin versions, for instance). QiBundleManager can expose the active bundle’s data so that when launching an application or loading an addon, the system can adjust behavior based on the bundle. This is more of a design consideration for the future—initially, focus on storing and retrieving bundle info.
Implementation steps:
Create a data model for a Bundle. This could be a simple Pydantic model or even a dictionary. For example: {"name": "production", "addons": {"addon-skeleton": "v1.0", "another-addon": "v2.3"}} – basically mapping addon names to version tags. (If version management is too much now, the “addons” mapping can be optional or empty.)
In QiBundleManager, initialize a default list of bundles. You might hard-code one or two bundles for now, or better, load them via QiDbManager’s file adapter (if you decide to store bundles in a file). A straightforward approach is to extend the existing qi.config.toml or have a bundles.toml. For example, qi.config.toml might have a section like:
```
[bundles.production]
addon_versions = {"addon-skeleton" = "latest"}

[bundles.staging]
addon_versions = {"addon-skeleton" = "dev"}
```
For now, manually define them in code if reading from file is not yet necessary.
Provide methods like list_bundles() (to get all bundle names or details) and set_active(bundle_name). The active bundle can be stored in QiBundleManager (and perhaps also saved to persistence so the selection persists between sessions, via QiDbManager).
Later, when launching DCC applications or loading addons, the active bundle information will be used. For example, QiLaunchConfig (the launcher settings) could incorporate bundle selection to decide which plugin versions to load. Keep this linkage in mind, but it can be implemented once bundle concept is solid.
Testing: Create tests for QiBundleManager to ensure that bundle definitions load correctly and that switching the active bundle updates the internal state. If QiDbManager is used, provide it a test stub for bundle data. By implementing QiSettingsManager and QiBundleManager, the application will have a central way to manage user settings and environment bundles, which is essential for the UI (to let users configure things) and for launching DCC apps in the correct configuration.

### 3. Refactor QiConfigManager to QiLaunchConfig
Currently, the main configuration class is QiConfigManager (a Pydantic BaseSettings) which reads environment variables and the qi.config.toml. Its purpose is to hold launcher configuration (server host/port, dev mode flags, SSL paths, etc.). To clarify its role, it’s a good idea to rename this to QiLaunchConfig (or similar), since it represents the configuration for launching the Qi application itself. Refactoring steps:
Rename the class in core/config.py from QiConfigManager to QiLaunchConfig. Update its docstring to reflect that it’s the application launch configuration. This is mostly a find-and-replace task: update the class name, the instance qi_launch_config, and any references in the code (for example, in hub.launcher.py where qi_launch_config.host is used, and in tests that import QiConfigManager).
If the tests refer to QiConfigManager, update them to use the new name. Run the test suite to ensure nothing is broken by the rename. Pydantic BaseSettings will still work the same under the new name.
Since this is purely a naming/refactor change, it should be straightforward. The benefit is improved clarity in the codebase (distinguishing between “config for launching Qi” vs. “settings managed at runtime via QiSettingsManager”). Note: In the future, if QiLaunchConfig remains mostly static (set at startup from env or file) and QiSettingsManager handles dynamic settings, we clearly separate immutable startup config from mutable user settings. The rename makes this conceptual separation more evident.

### 4. Extend the Plugin Base for Settings and Routes
The current QiPluginBase defines a minimal interface (discover, register, process) that every addon must implement. Now that we plan to expose plugin settings and possibly plugin-specific API endpoints, the plugin system needs to be richer. This involves both exposing plugin settings to the core and allowing plugins to contribute to the REST API or UI.

#### 4.1 Exposing Plugin Settings:
Each plugin/addon will likely have its own configuration options (for example, an addon might have enable/disable flags or paths to external tools). We want these to be integrated into the global settings so they can be managed through the /settings UI route and saved persistently.
Design: We can allow each plugin to define a settings schema, perhaps as a subclass of QiGroup or a simple dictionary that follows QiSettings conventions. For instance, a plugin could have a class or variable that defines its default settings (using QiProp/QiGroup). During application startup, QiSettingsManager can collect these plugin settings and merge them under a section of the global QiSettings (e.g., group them by addon name).
Implementation: Extend QiPluginBase to include an optional property or method, e.g., get_settings_def() which returns a QiGroup (or dict of QiProp) defining the plugin’s settings. The base class can provide a default empty implementation (for plugins that have no settings). Each concrete plugin (like addon-skeleton) can override this to supply its settings.
Integration: Modify QiSettingsManager’s initialization to iterate over all discovered addons and retrieve their settings definitions. These can then be attached to the global QiSettings object under a key like addons.<addon_name>. For example, if addon “example” has a setting structure, QiSettingsManager would insert it so it’s accessible as settings.addons.example.<setting_name>. This way, the /settings API can present both core settings and addon settings seamlessly.
Persistence: QiSettingsManager will also need to handle saving and loading these addon settings (likely they go into the same settings file under their section). Because the QiSettings schema now includes addon sections, the save/load logic will automatically include them.

 #### 4.2 Plugin-Specific Routes (Optional for future):
It’s desirable to let addons provide their own API endpoints (for specialized actions or data). For example, an addon could need a route to fetch some data from an external source, or perform an operation not covered by the core API. We should plan for a mechanism to inject plugin routes into the FastAPI app.
One approach is to allow QiPluginBase to define an API router. For instance, add an abstract method or property api_routes (perhaps returning a FastAPI APIRouter or a list of route definitions). The plugin can use FastAPI (or Starlette) to define route handlers. During server startup, the core server would include these routes (e.g., app.include_router(plugin.api_routes, prefix=f"/addons/{plugin_name}")).
In the short term, we might not implement full dynamic routing (since it adds complexity), but it’s good to design the server with extension in mind. We can place placeholders or simple examples: e.g., define a base route for each addon UI already (the server likely serves the addon’s front-end at /<addon_name> for the UI web page). We could reserve subpaths like /<addon_name>/api/... for addon-specific REST calls if needed later.
For now, focus on plugin settings integration, because that ties into the /settings endpoint we know we need. Document in the code (comments or TODOs) that plugin routes injection is planned. Perhaps implement a simple case: the Settings endpoint for an addon might actually be handled by core, but conceptually it’s “exposed by addon.” We can simulate that by structuring the path as /settings/{addon}/{...} (more in the next section). This at least establishes the URL pattern.

#### 4.3 Other Plugin Base improvements:
Evaluate if QiPluginBase should also handle other lifecycle events or resources. For example, should it have an initialize() method separate from discover()? Or a way to register event handlers on the message bus? Currently, the register() method likely is intended for plugins to subscribe their message handlers or provide connections. If needed, we can standardize how plugins register message handlers (maybe providing a list of message types they handle). However, this might already be addressed by how the Hub/HandlerRegistry works with plugin registration. In summary, make QiPluginBase less generic by formalizing common extension points: settings, routes, and bus handlers. This will make writing new addons easier and ensure they can integrate with the core features (like unified settings storage and central API).

### 5. Enhance the FastAPI Server with Settings & Bundle Endpoints
Now that QiSettingsManager and QiBundleManager are planned, the FastAPI server needs to expose these via HTTP endpoints so the front-end UI (or a user) can interact with them. We’ll add new REST API routes for settings and bundles, and ensure the server is structured to allow future routes.

#### 5.1 Settings API Endpoint:
Users should be able to view and modify settings through the UI. We will create a /settings endpoint (and sub-routes) to serve this purpose. Key points:
Route design: Use a path structure that can accommodate global settings and optional addon-specific settings. For example:
GET /settings – returns all settings (perhaps organized in a JSON, possibly large but useful for initial load of a settings UI).
GET /settings/{addon} – returns just the settings for a specific addon (e.g., /settings/addon-skeleton to fetch that addon's config).
We can also allow nested sub-branches if needed: e.g., /settings/{addon}/{section} if addons have internal grouping. However, if the entire addon’s settings are already a structured JSON, we might not need separate subpaths for sections; the client can filter as needed.
Handlers: Implement these handlers in the FastAPI app. Likely in core.server.server or a new router module. For example, a GET /settings handler would call QiSettingsManager.get_all() (a method we create to serialize all settings to dict) and return it as JSON. A GET /settings/{addon} would do similar but filter to that addon's subset.
Updates: Optionally, allow modifying settings via POST/PATCH. This could be a later addition, but we should plan for it. Perhaps a PUT /settings/{addon} that accepts a JSON body of that addon's settings to update. The handler would validate and apply them via QiSettingsManager (which in turn would save to persistence). Initially, we might implement read-only endpoints and leave write operations as TODO, unless immediate interactivity is needed.

#### 5.2 Bundles API Endpoint:
For bundle management via UI, provide a /bundles endpoint:
GET /bundles – returns the list of available bundles and possibly the currently active bundle. The data could look like: {"active": "production", "bundles": [{"name": "production", ...}, {"name": "staging", ...}]}. This allows the front-end to display what bundles exist and which is selected.
POST /bundles/select (or a PUT /bundles/active) – an endpoint to switch the active bundle. The client would send the name of the bundle to activate. The server handler will call QiBundleManager.set_active(name) and perhaps return the updated active bundle.
In the future, we might have more complex bundle operations (creating new bundles, editing them, etc.), but for now, focusing on selection is sufficient.
These routes will make use of QiBundleManager’s data. Initially, since bundle info might be static, the handlers are straightforward. But having the API in place prepares the ground for a UI to manage them.

#### 5.3 Optional Future Endpoints:
We anticipate other configuration or service endpoints, such as:
/addon_manager – to manage addon import paths or enable/disable addons. This might allow users to configure where Qi looks for addon packages or toggle certain addons on/off. Designing this requires more thought (and possibly ties into how addons are discovered and loaded), so we can leave it as a future improvement.
/window_manager – to configure UI themes or global UI settings (window theming, etc.). At the moment, there’s no explicit support for themes in QiWindowManager aside from a default frameless black background window. If theming or UI preferences become a feature, an endpoint could expose those options. For now, this can be noted as a placeholder.
/services/* – The idea of “hardcoded dirs for configuration” suggests possibly grouping some settings or management tasks under logical URLs. For example, GET /services/window_manager/theme or POST /services/addon_manager/rescan. This needs concrete use cases before implementation. We should document these ideas but not implement them until the requirements are clear, to avoid over-engineering.
Server Refactor for Route Injection:
To keep the design clean, consider refactoring how the FastAPI app is constructed:
Instead of defining all routes in one place, use FastAPI routers for different concerns. For example, create a router for settings & bundles (settings_router), and include it in the main app with a prefix (maybe /api prefix or none). This modular approach will make it easier to inject new routes.
When plugins want to add routes (as discussed in Section 4.2), you can include their routers similarly. Possibly do something like:
```
app.include_router(settings_router)  
app.include_router(bundles_router)  
for plugin in loaded_plugins:  
    if plugin.api_router:  
        app.include_router(plugin.api_router, prefix=f"/api/{plugin.name}")  
```
(Using an /api prefix is optional; it could also be top-level like /myplugin/route, but that could clash with the addon’s UI route. Perhaps prefixing with /api or another namespace is safer to distinguish from UI pages.)
Ensure the server still serves the static frontend content for each addon at the root path /<addon>. That functionality remains as is (likely handled by Starlette StaticFiles or a proxy in dev mode). The new API endpoints should not interfere with that. In practice, having /settings and /bundles at root is fine, since those don’t collide with an addon name (unless an addon is unfortunately named "settings" or "bundles", which we can disallow).
After refactoring, test the server manually or via new unit tests: start the server and hit the new endpoints to see that they return the expected data from QiSettingsManager and QiBundleManager.

### 6. Integrate Window Management with the Message Bus
Currently, QiWindowManager can create and destroy windows, but these actions need to be hooked into the messaging system so that the front-end and back-end stay in sync about open windows. Additionally, controlling windows (open/close) via messages will allow more dynamic behavior (e.g., user clicks a "open new window" button in one UI, which sends a request to open another addon window).

#### 6.1 Bus Commands for Window Open/Close:
Leverage the existing message bus (the core.messaging Hub/MessageBus) to handle window lifecycle events:
Open Window: Define a message/event type, for example "window.open" (with payload specifying which addon to open, and perhaps a session identifier if applicable). When a client UI wants a new window, it can send this message over the WebSocket. The hub on the backend should dispatch it to a handler that invokes QiWindowManager.create_window(addon=..., session_id=...). We may need to decide what session_id to use: the message could either specify a target session (like open a window as part of the same user session) or we generate a new one. A reasonable approach is to treat each top-level window as a separate session context – so opening a new window would create a new session ID (as QiWindowManager already does if none provided). The message might not need to include session; the backend can handle it.
Close Window: Similarly, define "window.close" events (payload: window_id or perhaps addon+session). When a UI window is about to close (or the user requests it via UI), it should notify the backend. The backend handler will call QiWindowManager.close(window_id). This ensures the window is destroyed and removed from _windows dict. Also, the back-end can then broadcast a confirmation or update to other parts of the system if needed (e.g., updating a UI list of open windows).
To implement this, you’ll likely use the HandlerRegistry/Hub system already in place. For example, when initializing the application (or specifically the WindowManager), you can register handlers:
hub.register("window.open", window_manager_handle_open)  
hub.register("window.close", window_manager_handle_close)  
Where those handler functions simply call the QiWindowManager methods. The commented-out bind_window_manager(window_manager) in hub.launcher might have been intended for this – you can create that function to do the registrations.

#### 6.2 Session Register/Unregister Tie-in:
Each window corresponds to a WebSocket connection (the window’s frontend will connect to /ws with its session_id). The connection management (likely in ConnectionManager or Hub) already tracks active sessions. Opening a window eventually results in a new session being registered when that window’s JS connects to the WebSocket (it uses the URL params session_id and window_id that QiWindowManager appended). Closing a window will cause that WS connection to drop, triggering a session unregister. To ensure consistency, when handling "window.close" from the UI, the backend should attempt to cleanly close the window and perhaps pre-emptively unregister the session. However, pywebview’s window.destroy() should naturally lead to the WS disconnect event, so it might unregister itself. We just need to ensure no stale references remain. It’s worth testing: open a window, close it, and verify that ConnectionManager’s list of active sessions decreases and QiWindowManager’s _windows dict no longer contains it.

#### 6.3 Optional UI Controls via Bus:
Beyond open/close, other window actions (maximize, minimize, focus, etc.) could be exposed via the bus if needed. The user’s note suggests visual layout changes can be handled on the front-end side via the bridge (i.e., directly in JS or using pywebview’s JS API). That means we don’t necessarily need bus messages for things like resizing or moving windows – those can be done by the OS window manager or webview JS integration without round-trips to Python. This keeps the bus simpler and avoids latency for frequent UI interactions. If there are specific window commands to add, consider ones like:
"window.list" to request a list of open windows (though this could also just be a direct REST call to an endpoint, or the UI can keep track if it’s the one opening them).
"window.focus" to bring a window to front (pywebview might expose something like window.bring_to_front() which could be invoked via QiWindowManager.invoke).
These are low priority unless a clear use-case emerges.

#### 6.4 Front-end Integration:
Ensure that the front-end (Svelte apps in the addons) knows how to send/receive these window-related messages. For example, the addon-skeleton could have a button that triggers something like:
bus.send("window.open", { addon: "someAddonName" });
Then on success, maybe the backend could reply or broadcast a "window.opened" event with the new window_id or confirmation. However, since the new window will independently connect via its own session, the initiating window might not need a direct confirmation except perhaps to show an error if creation failed. Simplicity: the initiating UI can fire the open message and rely on QiWindowManager to do it. If needed, QiWindowManager can send back a response or log error (the log is already capturing if creation fails). By integrating these, opening and closing windows becomes a coordinated action visible to the whole system: the backend manages state and the front-end can trigger it through the unified message bus, rather than calling QiWindowManager directly (which front-end cannot do anyway). This fits the event-driven design of Qi.

### 7. Testing and Iterative Integration
As we implement each of the above components, it’s important to do it incrementally and keep the system testable:
Update and write unit tests for QiDbManager, QiSettingsManager, QiBundleManager, and any new server routes. For example, you can write tests that call the FastAPI app’s test client for /settings and /bundles endpoints to ensure they return the expected data structure.
Ensure that existing tests still pass, especially after refactoring QiConfigManager (rename) and adding new functionality. The window manager changes might require simulating message events; possibly extend the integration tests for the hub to include a scenario of sending a "window.open" message and asserting that a new window appears in QiWindowManager’s list. (You might mock the actual webview window creation to avoid opening GUI windows during tests – e.g., monkeypatch webview.create_window to a dummy function.)
Gradually enable pieces of the commented-out launcher code. For instance, after implementing the new window open logic via bus, you might not need to auto-create all addon windows at startup as was temporarily considered. Instead, perhaps launch a main UI window (like a login or dashboard addon) on start, and let that UI open others as needed. Adjust hub.launcher.qi_gui_launcher accordingly – maybe just start the server and then create an initial window for the main interface (if applicable, e.g., an addon could be a “home” or “project selection” screen). Then call window_manager.run(). Test that this flows correctly (in dev mode and packaged mode).
Throughout this process, maintain good documentation in code and commit messages for each step, since this is a significant expansion of functionality.
Conclusion: Roadmap Summary
To summarize, the immediate next steps for Qi’s development are:
Foundation – QiDbManager: Create a robust facade for data storage and external integration, allowing testable interactions with auth (Ftrack) and local file storage.
Configuration Management: Build QiSettingsManager and QiBundleManager on top of QiDbManager. These will handle user settings and environment bundles, respectively, enabling persistent configurations and bundle-based context switching.
Renaming and Refactoring: Clean up nomenclature by renaming QiConfigManager to QiLaunchConfig (improving clarity between startup config vs. runtime settings).
Plugin System Enhancements: Extend QiPluginBase to allow addons to specify settings (to be merged into global settings) and prepare for future route contributions. This makes the plugin architecture more expressive and integrated.
REST API Extensions: Refactor the FastAPI server to include new endpoints for settings and bundles. This gives the front-end a way to query and modify configurations. Design the server with a modular router approach to accommodate plugin routes down the line.
Window Manager & Bus Integration: Connect QiWindowManager with the message bus so windows can be opened/closed through unified events. This ties the front-end UI actions with back-end control, keeping session management in sync. Only implement the essential commands (open/close) for now, handling finer UI controls within the front-end context.
By tackling these steps in order, you will create a more cohesive and functional system. Once these are in place, Qi will be able to log in users, manage settings through a UI, allow selection of environment bundles, open multiple tool windows on demand, and maintain a synchronized state across its components. Each piece builds upon the previous, so following this plan will ensure the development progresses logically and remains testable at each stage. Good luck with the implementation!

## FIRST REPO SCAN + PLANNING COMMENTS

1 - QiDbManager can have adapter stubs that work on files for now. I would already implement the high level api for it, we should not have devs interacting with the adapters directly.

2.1 - Yes, Noted.

2.2 - Yes, Noted.

3 - Yes, Noted.

4.1 - There should be a mechanism already planned in the QiSettings method, namely get_values and get_schema. It is meant to be consumed mostly by UIs, but probably it can also be used by internal features. QiSettingsManager can then use that to overlay overrides and return the needed data upon request. This would (and should) also extend the rest api surface at /settings/... automatically, so UIs and optionally plugins can call directly there if needed.

4.2 - Noted.

4.3 - Yes we should plan on standardizing the plugin interface, we just need to be sure it plays along nicely with pyblish.

5.1 - Yes, as above.

5.2 - Yes, Noted.

5.3 - /addon_manager should be a part of the general settings UI, not a specialized addon. We can use routes in sveltekit for that. No plan in supporting this now. /window_manager too, we can placehold it but not needed now. /services/* is also something not needed now: we have the bus for most of that logic anyway, no point into having a complete rest surface aside from settings and whatever the addon developer decides to expose.

6.1 - Yes, we still need to refactor the QiWindowManager class. Our plan was to use the pywebview api bridge to handle window controls (minimize, maximize, hide, show, move, resize, close), plus a couple of bus handlers to automatize close in case of special logic (such as session teardown, close all windows). Ideally only opening and closeing should be handled with the bus, so we can keep the message system clean (resize and move can dispatch hundreds of messages per second and pollute the logs), and the status of the window itself is not really relevant to the system aside from Open/Close.

6.2 - As above, since window close can be triggered by hub, teardown also triggers it for all children windows.

6.3 - As above, all window state functionality should be handled with pywebview js api commands. The windowmanager will nee dto expose those calls through its interface, code still need to be done.

6.4 - The addon-skeleton already features code to subscribe and publish from JS to the owned websocket connection. This part will be handled separately.


# SECOND REPO SCAN + PLANNING

Implementation Status of Qi Application Components

### Launch Configuration & Core Setup:

QiLaunchConfig / QiConfigManager: The configuration system is implemented via QiConfigManager (a Pydantic BaseSettings subclass) to parse .env/TOML/CLI flags. It provides core flags (dev_mode, headless, etc.) and reads an addon_paths list
This appears production-ready for loading config, but it’s relatively simple. In the main startup (hub/main.py), the app instantiates qi_launch_config and then either launches GUI mode or warns that CLI mode is unimplemented.
There is no dedicated QiLaunchConfig class separate from QiConfigManager – likely a naming shift. Overall, basic config loading is complete, but using those configs to drive complex startup logic (like selecting projects or bundles) is not fully implemented (e.g. default_project/--project handling is absent). The initial bootstrap flow (spec “0.1 Parse CLI → QiLaunchConfig”) is partially there, but anything beyond reading flags (like default project selection) is not yet realized. Core Initialization: The main sequence sets up logging and attempts to start the application. Notably, it spawns the FastAPI server on a background thread and intended to then initialize the GUI (window/tray) on the main thread. However, the GUI launch is commented out in the current code, indicating this integration is incomplete. For example, hub/launcher.py shows that creating the QiWindowManager and binding it was planned but disabled
The code to create windows for each addon and start the GUI event loop (webview.start) is also commented
This means the application currently only brings up the backend server and does not open any UI windows or tray – a clear gap from the intended design.
GUI & Windowing System

### QiGuiManager / Windowing:
The GUI subsystem is only partially implemented. The QiWindowManager class exists and manages PyWebView windows in a singleton pattern. It can create new frameless windows given an addon name and session ID, generate the proper URL with session tokens, and maintain a registry of open windows
The window manager supports listing and closing windows and ultimately calls webview.start() to run the UI loop
This suggests the window management code is present and likely functional, but as noted, it’s not wired into the launch sequence yet (the calls to actually create and show windows are commented out). Tray Icon: The QiTrayManager (tray icon controller using pystray) is not implemented at all in the codebase. The plan (per spec) was to have a PyStray-based tray icon that could show menu options, and to run it on a separate thread
However, no QiTrayManager class or pystray usage appears in the code, aside from the pystray library being listed as a dependency
This indicates the tray functionality is still a stub – likely intended but not started. Assessment: Windowing is implemented at the class level (QiWindowManager) but not integrated, and tray support is nonexistent so far. The GUI subsystem is partial and not user-visible in the current state. Aligning with the architecture (which calls for a GuiManager coordinating windows and tray), the code needs to actually instantiate these managers, handle events (like window open/close, tray clicks), and connect them to the message bus. Right now, those pieces are missing or disabled.

### Hub & Messaging Infrastructure:
QiHub and Message Bus: The core IPC hub is one of the most fleshed-out parts and appears well-aligned with the architecture goals. The QiHub class serves as a high-level facade to the messaging system, providing developers with a simple API (hub.on(), hub.publish(), hub.request(), etc.)
Internally, QiHub owns a single QiMessageBus instance and delegates all operations to it. The message bus (QiMessageBus) is thoroughly implemented: it maintains a QiConnectionManager for tracking active WebSocket sessions and a QiHandlerRegistry for topic handlers. It also implements the full publish/subscribe and request/reply pattern described in the spec, including queuing requests, awaiting replies, and enforcing a max pending request count per session
The code handles broadcasting events vs. directed requests correctly, and will route the first non-None handler result back as a REPLY message automatically
This matches the intended design of a central pub/sub hub with request-response capability and is likely production-quality (there are even async tests for the message bus). Connection & Session Management: The QiConnectionManager supports multiple named sessions and parent/child session hierarchies (for DCC processes) as planned. When a new WebSocket connects, it calls qi_hub.register(), which in turn calls the connection manager. The code ensures that if a logical ID is reused, the old session is torn down first (preventing duplicates).
It also links child sessions to a parent via parent_logical_id, maintaining a tree so that closing a parent can auto-remove its children. This parent/child concept is exactly the “session” and “child session” model needed for DCC hosts launching subprocesses. In summary, the messaging layer is robust and aligns with the spec’s hub design: we have a working websocket-based message bus with topic-based handlers, session lifecycle management, and the groundwork for role-based message handling (though the “role” concept is not yet utilized beyond the parent/child linking). Server Integration (WebSockets): The FastAPI server is set up with a single /ws endpoint that accepts WebSocket connections
On connect, it expects a JSON payload to initialize a QiSession (with id, logical_id, etc.), then registers that session with the hub incoming messages on the socket are received in a loop and handed to qi_hub.public() for dispatch to handlers.
This means the backend can already accept connections from the main UI and DCC clients and route their events appropriately. The basic server and hub interplay is in place and working. Gaps: The hub/messaging subsystem is mostly production-ready. A minor gap is the spec’s notion of role-based addon loading via topics (auth., db_service.) which implies that certain topics must be handled by exactly one provider. Right now, the bus can route these topics, but ensuring exactly one auth/db handler is loaded is not enforced because addon loading isn’t done (see below). That guard (spec “1.4 Guard: if 0 or >1 provider handlers → fatal”) will need implementing once providers exist. Another future addition is event hooks on connect/disconnect (the code has _event_hooks in QiHub and calls _fire("register", session) on new connections, presumably for things like notifying addons when new sessions start. This is already in place, though not widely used yet. All told, the hub/bus is a solid foundation and aligns well with the intended dual IPC (pubsub + request/reply) design.

### Addon Management & Lifecycle:
This is an area that is mostly scaffolding with little actual implementation. The architecture envisions a QiAddonManager to discover and manage addon modules, plus a lifecycle with phases: discover, register, install. In practice, no such manager class or lifecycle orchestration exists yet in the codebase – meaning addons are not really being loaded or initialized at runtime. Discovery of Addons: The config defines an addon_paths list (by default just "addons" directory), and there is a utility to scan these directories. In hub/lib/utils.py, get_addons() will look at each path and list subfolders containing an addon.py file. However, this function is never called as part of startup – it seems to serve development scenarios (especially with Vite dev servers for UI). In production mode, it would populate a dict of discovered addons (name -> path/URL), but currently the code does nothing with that info. There’s no code to actually import the addon’s Python module or instantiate anything. So, addon discovery is at a prototype stage – the application knows where it would find addons, but doesn’t yet load them. Addon Roles (Auth & DB Providers): The spec dictates a preload phase to scan for addons with role "auth" and "db" to provide authentication and data services. In code, there is no explicit handling of roles. The expectation was possibly that each addon’s addon.py or addon.toml would declare a role, or perhaps naming conventions. Because addon loading hasn’t been implemented, none of this role-based logic is active. The guard against multiple auth providers (spec 1.4) and the initial handshake via an AuthService are effectively just plans on paper right now. For example, there is no AuthService or QiAuthProvider class in the repository – no Ftrack integration yet, just the placeholders in the spec. Addon Registration Phase: After login, the design calls for loading all addons in the active bundle, instantiating each, and calling their register() method so they can attach bus handlers, CLI commands, and REST routes. Since addons aren’t being imported at all, this whole sequence is unimplemented. Notably, the codebase does not define a QiAddonBase class or similar that addons subclass – likely an omission that’s yet to be developed. We do see an “addon-skeleton” present in the repository (with a Svelte UI and presumably meant as a sample addon), but its Python entry-point (addon.py) is either missing or not indexed. As it stands, addons cannot register any functionality because they aren’t loaded into the app process. Addon Plugin Content: Within addons, the spec defines a structure (plugins folder for creators, loaders, publish plugins, etc.). None of the logic to iterate those directories or load plugin classes exists yet. The core does provide a QiPluginBase abstract class for all plugin types, which defines the expected interface (discover(), register(), process() methods). However, there is no code that actually uses QiPluginBase beyond defining it. For instance, no mechanism scans an addon’s plugins/create folder and instantiates those plugins. In short, the concept of pluggable behaviors is present (via the base class and spec), but the implementation to realize it is absent. The Pyblish integration for publish plugins is similarly not wired up – although pyblish-base is listed as a dependency, we find no code invoking Pyblish or handling publish plugin registration. This suggests publish plugins are still theoretical at this point. Summary: Addon management is largely a stub. The architecture’s goals (dynamic addon discovery, role-based loading, and lifecycle hooks) are not yet met by the code. We have basic file-system scanning utilities and abstract classes, but no addon manager to tie them together. This is a critical gap: without addon loading, features like Auth, DB, and DCC hosts cannot function as intended. It’s clear this will need significant development to move from scaffold to a working system.

### Bundle Management and Environments:
The concept of Bundles – distinct sets of addons and configurations (Production, Staging, Dev, etc.) – exists only in documentation. The spec defines bundle states and the idea of a “current active bundle”, but the codebase contains no QiBundleManager or bundle handling logic. There is no representation of bundles in code (e.g., no classes or data structures for them, no commands to switch bundle). The only trace is the config’s addon_paths which could be pointed to different bundle folders manually. Essentially, the application today assumes one set of addons (whatever is in the addons/ directory) is active. Enforcement of a single Production vs Staging bundle or versioned bundle contents is not implemented at all. Additionally, environment management for launching DCCs (ensuring the correct environment variables, etc., per bundle) is not present. We don’t see any code that prepares subprocess env settings or differentiates between contexts. The bundle mechanism is unimplemented beyond a placeholder in spec. For an MVP, likely a single “default” bundle is used. Eventually, a QiBundleManager is needed to load bundle definitions (perhaps from config or DB) and filter which addons to load (spec step 4.1 mentions using a bundle allow-list for addons). Right now, since all addon loading is off, bundle selection is moot – everything is effectively a single bundle.

### DCC Host Launch & Session Lifecycle:
Multi-Session Support: On the positive side, the infrastructure to handle multiple sessions (main app and DCC app sessions) is in place. As discussed, QiConnectionManager tracks parent/child session relationships and the message bus can route messages either broadly or to specific logical IDs. This means if a DCC process connects back to Qi’s hub, it will be managed as a child session under the main app session (the parent). The “bubble” logic (routing messages to a parent if bubble=True) is supported in QiMessageBus, though currently bubble is always set False in message creation. So technically, the groundwork exists for child sessions to communicate with the main hub and for messages to bubble up if needed. Launching DCC Processes: What’s missing is everything on the launch side. There is no code to actually spawn external DCC applications. We would expect an addon with host capabilities to call something like subprocess.Popen() with the DCC’s executable, set up the environment (PYTHONPATH etc.), and include a way for that DCC to initiate a Qi client session on startup (perhaps via a bootstrap script or command-line argument). None of this logic is present yet. The spec envisions addon hosts handling this (possibly via an addons/.../host/ module or in addon.py), but since addons aren’t loaded, no DCC launch commands exist. Even a simpler case like launching a stub process is not implemented. Session Lifecycle Management: Beyond launching, managing the lifecycle (ensuring a DCC session disconnects on app exit, or terminating processes) hasn’t been coded. The spec outlines a SessionManager.teardown_all() both for headless exit and GUI quit. This implies a component that tracks all active sessions/processes. In code, there is no SessionManager class. Cleanup in the current state is limited to what QiConnectionManager does when sockets disconnect. So if the main app closes, it will call hub.unregister() on each session, which triggers WebSocket closures and informs the connection manager to remove them. But terminating the actual DCC processes would require explicit handling (e.g., killing the subprocess or sending an IPC message to shut down). That part remains to be implemented once process launching exists. Conclusion: Support for DCC integration is largely scaffolding at this point. The session architecture can accommodate multiple DCCs (which is good and in line with the design), but the actual ability to start and manage those DCC sessions is unfulfilled. We should consider this feature “designed but not built.” It’s not production-ready, just ready to be built upon.

### Settings Management:
The settings system is partially implemented as an internal schema builder, but it’s not yet connected to external override data or any UI. In core/bases/settings.py, there is a framework to declare settings as a tree of QiProp (leaf values) and QiGroup (nested groups). This allows defining a hierarchical settings schema in code and then building a Pydantic model out of it at runtime. Notably, QiSettings is the root group and on context manager exit it auto-builds the model. So, a developer can do something like:
```
with QiSettings() as settings:
    settings.general = QiGroup(...)
    settings.general.option = QiProp(default=123).
```
This would produce a runtime model accessible via settings.get_values() etc. The mechanism to define and assemble default settings is therefore in place. It’s quite sophisticated (supporting list/dict modes, validators, and metadata for UI form generation). Overrides and Merging: However, the next steps described in the architecture are missing. The spec’s “Settings & Bundle Resolution” phase (step 3) outlines reading bundle-level and project-level overrides (likely from the database or config files) and then merging them with the defaults. In code, we have no SettingsManager.collect_defaults() or a function to merge different layers of settings. The QiSettings system can give you a default schema and values, but combining multiple sources of values isn’t implemented. We don’t see any use of the watchdog library yet, which was presumably included to watch override files on disk for changes (as hinted by spec step 7.2). So, currently, there’s no dynamic override loading or file watching. Accessing Settings at Runtime: The design calls for exposing settings via both the message bus (topics like config.get and config.patch) and REST (perhaps routes to fetch or update settings). None of these are present. There are no handlers registered for config topics, and the FastAPI app has no endpoints for settings. So, while the data model for settings exists, it’s siloed – not interactive. There is also no Settings GUI implemented to allow users to view or modify settings in-app. The spec mentions a GUI for settings overrides, but that likely would come once the backend supports those operations. Stability: The parts that exist (schema definition and model building) have unit tests (e.g., for merging default entries) and seem stable. But since it’s not integrated, we’d rate the settings feature as “stable but partial.” It’s a solid foundation awaiting the layers that make it useful. Key missing pieces are: loading real settings data from somewhere (database or files), merging logic (defaults → bundle → project), and any form of UI or API to expose the effective settings.

### CLI Interface:
The CLI (headless) mode is essentially not implemented beyond argument parsing. As noted, if qi_launch_config.headless is true, the app simply logs a warning that no CLI is available. The design intended a QiCliManager that would collect CLI subcommands from addons and execute commands in a headless context. There is no QiCliManager in the codebase. We also do not see any CLI parsing library usage (perhaps relying on Pydantic’s BaseSettings CLI capabilities which are currently disabled via cli_parse_args=False in QiConfigManager). This suggests CLI support was deprioritized. Without a CLI manager, headless mode cannot run addon-defined commands or any extended logic – it simply isn’t functional. For practical purposes, the application must run in GUI mode at this time. The CLI is a clear stub and will need development (likely after the core addon system is in place, since CLI commands would come from addons).

### REST API Surface:
The FastAPI-based server component (“qi_server”) is up and running, but it currently only provides a very limited API surface: a root GET for health-check and the /ws WebSocket endpoint. The intent was to offer a parallel REST interface to complement the realtime bus – for example, addons could register REST routes (perhaps under /api/...) to expose data or operations, and the settings system would expose HTTP endpoints for fetching or updating config. At the moment, none of that is done. We do not find any calls to qi_server.include_router or qi_server.add_api_route outside the basics. The spec calls for registering addon routes and settings routes during startup, but this is unfulfilled. Static File Serving: The one part of the HTTP server that is implemented is static content serving for addon UIs. The QiDevProxyMiddleware and QiSPAStaticFilesMiddleware intercept HTTP requests to serve addon front-end files either from a Vite dev server (in development mode) or from the built ui-dist directories (in production). This means the web UI of addons can be loaded in the PyWebView windows. Indeed, QiWindowManager opens windows pointing to http://localhost:8000/{addon_name}?session_id=..., and the middleware will ensure the addon’s index.html and JS are served. This part appears functional and has been tested (there are realistic middleware tests). Authentication & Security: Currently, there is no authentication on the REST endpoints or WebSocket. The spec envisioned using JWT tokens (acquired at login) to secure API calls and possibly the WebSocket handshake. In code, we don’t yet generate or require any auth tokens for connecting – any client that knows the host/port can open a WebSocket. This will need to be addressed when integrating an AuthProvider. For now, the REST API is open and minimal. Dual API Goal: The “dual API surface” – having both a synchronous REST interface and an async bus – is not yet realized in full. The bus side is there, but the REST side has to be expanded. We expect in the future to have routes for things like querying project data (GET /api/projects) or triggering actions (POST /api/actions/…) as complements to doing the same via hub messages. Achieving parity and deciding what goes over REST vs WS is part of finalizing the design. At present, developers can only use the WebSocket for any meaningful interaction; the REST interface should be considered placeholder. Finalizing it will involve hooking in all addon-provided API routes and securing them properly.

### Summary of Subsystem Status:
- Configuration & Launch: Basic config reading is done; advanced launch logic (project selection, bundle config) is not.
- GUI/Tray: Window manager implemented but not invoked; tray manager not implemented. Not production-ready (UI not launching yet).
- Hub/Bus: Fully implemented and tested. Aligns with design (pub/sub, request, sessions). Production-ready core for IPC.
- Server/REST: WebSocket endpoint working for bus; HTTP serving static files; no addon REST endpoints yet, auth not implemented.
- Addon System: Discovery and loading not implemented beyond a stub. No addon manager, no role handling, no lifecycle execution.
- Plugin Framework: Abstract base exists; no plugin discovery/registration in practice; Pyblish integration missing. (Effectively idle code).
- Bundle Management: Not implemented. Only a single hard-coded bundle (addons folder) scenario exists.
- Auth & Database (Ftrack): Not present. Intended to be provided by addons, but no such addon in place yet. Currently using a dummy file DB or none at all.
- DCC Integration: Scaffold only. Multi-session communication is supported, but launching DCCs and managing their lifecycle is unimplemented.
- Settings: Schema builder in place (supports defaults and model creation). Override merging, live updating, and UI not done.
- CLI: Stub. Headless mode cannot run any commands yet.

Each subsystem has portions that meet the architecture and other portions that are still just intentions. The messaging hub stands out as mature and largely complete. Most other areas – especially those involving extensibility (addons, plugins, external integration) – are partial or awaiting implementation. Next, we outline a development roadmap to address these gaps and progress Qi toward an MVP.
Development Roadmap and Next Steps
Achieving architectural completeness and an MVP-ready state will require tackling the subsystems in a sensible order. Below is a proposed sequential plan:

### 1. Addon Management & Lifecycle Implementation
Why: Addons are the extension mechanism for Qi (auth, database, hosts, UIs, plugins all come via addons). Until the addon system works, many core features remain blocked or hard-coded. Tasks:
Define a QiAddonBase class that addons must subclass (in their addon.py). Give it methods for lifecycle: discover(), register(), install() (mirroring the spec) and possibly attributes like role (to tag an addon as "auth" or "db" provider).
Implement QiAddonManager: This service will:
Scan qi_launch_config.addon_paths for addons (using logic from get_addons() to find folders with addon.py).
Import each addon as a module/package. This means ensuring addons/ is on sys.path or using importlib to load by path.
Instantiate each addon’s QiAddonBase subclass. Possibly maintain a registry/dictionary of addon instances.
Handle role-based loading: perform the “Phase 1” load of provider addons. For each discovered addon, if it declares role="auth" or "db", initialize those first (before auth handshake). Enforce that exactly one auth and one db provider are present; if not, log an error and abort (as per spec guard).
After auth (and after bundle selection), do “Phase 2” loading: initialize all remaining addons that are allowed by the active bundle. For MVP, this can just be “load all non-provider addons,” since bundle filtering isn’t in place yet. In future, QiBundleManager would supply an allow-list for this phase.
Addon Lifecycle Hooks: Upon instantiation, call addon.discover() for any early setup. Then call addon.register(). During register(), the addon uses the hub’s API to subscribe to topics or register event handlers, and it should call into sub-systems to extend them:
e.g. an addon could register bus handlers via qi_hub.on("some.topic", ...) or provide CLI commands via a CliRegistry (to be developed).
If the addon has a tray menu extension or needs to open a UI window at startup, this is where it would request it (perhaps via a hub event to the GuiManager or directly calling QiWindowManager.create_window()).
The addon can also enqueue any REST API routes it needs (maybe collecting FastAPI APIRouters to include later).
Integration: In the main launch flow, create the QiAddonManager early. Likely:
Before starting the FastAPI server, call addon manager to load provider addons (auth/db).
Then start FastAPI (so that if the auth addon provides a login REST endpoint or static content, it’s available – though in our design, login is via UI, not REST).
Perform Auth handshake (see next step).
After successful auth, use addon manager to load remaining addons, then proceed to GUI bring-up.
Error handling: If any addon fails to load or has conflicts (like duplicate roles), Qi should log a critical error and exit (so misconfiguration is obvious).
Testing: Develop a simple example addon (or use the skeleton) to verify that the manager imports it and calls its methods. For example, a dummy addon that prints a log in discover and registers a trivial bus handler can prove the mechanism works.
This step will move addon support from theoretical to functional. It unlocks the ability to cleanly implement the following features (auth, DB, hosts, plugins) as addons rather than hardcoding them.

### 2. Authentication & Database Provider (Auth Handshake)
With provider addons loading, implement the Auth handshake (Flow Step 2) using the new system:
Develop an Auth addon (could be called qi-auth-ftrack or simply a mock for now) that has role "auth". Initially, implement it as a mock authentication: for MVP, it might present a login UI and validate against a dummy user list or always succeed. Later, it would integrate with Ftrack API.
This Auth addon should:
On register(), subscribe to an auth.login topic on the hub. Provide a handler that takes credentials and returns a result (token/user info).
Possibly also handle auth.logout or token refresh topics if needed.
Expose a UI for login. Likely, the addon will have a front-end (Svelte UI) for the login screen. Qi can launch this UI window at startup if no valid credentials are present.
Store the obtained token/user in a central place (maybe QiDbManager or the addon itself). Qi could also stash it in memory for use in API calls.
Develop a DB addon (role "db") that for now uses a simple file or in-memory store (like the QiFileDb mentioned in spec). It can respond to queries like db_service.project.list or db_service.bundle.list. For MVP, it might serve a static list of projects and a default bundle configuration. The key is to satisfy the calls Qi will make during startup:
When Qi needs to fetch project list or bundle info, it should request it via the hub (e.g., hub.request("db_service.project.get")) and the DB addon’s handler replies with data.
The DB addon can also provide methods to get settings overrides for a project or bundle (even if just returning none for now).
Auth Flow Integration: Modify the main startup:
After provider addons are loaded (phase 1), trigger the authentication sequence. For GUI mode: open a Login window (possibly via QiWindowManager.create_window(addon="auth-addon", session_id="auth-session")). The Auth addon's UI will allow the user to input credentials. On submission, the UI should send a WebSocket message on topic auth.login with the entered creds. The Auth addon backend handler (subscribed via hub) will process and reply with token/user data.
In headless mode (for future CLI), Qi could instead look for a saved service token or prompt on console – but since CLI is not MVP, focus on GUI.
On receiving a successful reply, Qi knows the user is authenticated (perhaps QiHub can expose a synchronous hub.request() call for this, or handle via event callback).
Store the credentials (token) for session – possibly in a global or in QiDbManager (to be created as part of DB addon).
Continue to next phase only if auth succeeded. If not, allow retry or exit.
The auth token can now be used to protect the FastAPI endpoints if desired (e.g., attach a FastAPI dependency that checks a token for any future protected routes). This might be lower priority for MVP if running on localhost only, but worth planning.
This step ensures Qi can connect to a user account (even a dummy one) and select a context for operation (project).
Note: If implementing Auth and DB as addons feels too complex initially, an alternative interim solution is to hardcode a “MockAuth” in Qi itself to get through login. However, given the addon system from step 1, it’s better to dogfood it by making Auth the first real addon.

### 3. Settings Overrides & Configuration UI
With a user logged in and a project/bundle known, Qi can load and merge settings, then present them if needed:
Implement override loading and merging: Now that we can identify the current project and bundle (from DB addon or config), query the DB addon for any stored settings overrides. For example, call hub.request("db_service.settings.get", {"project": current_project, "bundle": current_bundle}). The DB addon (if using QiFileDb) could read JSON or TOML files that contain override values. Use these to produce two dictionaries: bundle_overrides and project_overrides.
Enhance the existing QiSettings system to support merging:
Perhaps create a new class QiSettingsManager that wraps the QiSettings schema. Provide a method like apply_overrides(defaults, bundle_over, project_over) that deep-merges values (bundle values overriding defaults, then project values overriding those). Pydantic models can be updated with partial data via .model_validate or constructing with **override_dict.
Ensure that only keys present in the overrides are applied, and that type validation is respected.
Once merged, store the final effective settings in memory.
Expose settings via API and Bus:
Register hub handlers for config.get (to return the current effective settings or a subset) and config.patch (to update settings at runtime). The handler for config.patch should update the in-memory settings model and also persist the change via the DB addon (e.g., write to the overrides store for the project or bundle). Initially, to simplify, you could log that persistence is TODO and just update memory.
Add FastAPI routes under, say, /api/settings that allow GET (return entire settings JSON schema or values) and PATCH (to modify a value). Use Pydantic’s schema from QiSettings.get_model_schema() to help generate a JSON schema for UI forms if needed.
Settings GUI: Develop an interface to display and edit settings. This could be an addon (like a “settings” addon that contributes a UI). However, it might be simpler to integrate into an existing UI: for MVP, perhaps the main application window or tray menu can have a “Settings” option that opens a settings window. The UI would fetch the settings via REST or bus and present a form. Given time constraints, a rudimentary UI that lists settings and allows editing raw JSON could suffice for internal use, but ideally we use the metadata (titles, descriptions from QiProp) to make it user-friendly.
Testing: Try changing a setting via the UI or an HTTP call and ensure:
The in-memory settings update.
If the setting is something that affects behavior, that behavior changes. (For example, a setting could be “default asset directory” – the change should reflect next time an addon reads that setting).
If file-watching (using watchdog) is a target, implement a background task to watch override files and auto-apply changes. This can be a later enhancement; for MVP, manual refresh is fine.
This step makes Qi’s configuration dynamic and user-adjustable, moving closer to a real application feel. It also sets the stage for addons to start using those settings (e.g., an addon might query a setting value during its operation).

### 4. Plugin Loading & Execution (Pyblish Integration)
Now tackle the core pipeline plugins within addons:
Plugin Discovery: For each addon loaded in step 1, extend the addon manager to automatically discover plugin classes. This could happen during the addon's discover() or register():
Search the addon's plugins/ directory subfolders (create/, load/, hooks/, publish/, actions/). For each .py file, import it (ensuring the addon's package is on path).
Use Python inspect to find classes subclassing QiPluginBase in those modules. Instantiate each one. The base class constructor will call its _discover() and _register() by design, which in turn call the overridden discover() and register(). This means plugin-specific initialization and bus handler registration happens immediately upon instantiation.
Keep track of these plugin instances if needed (for later use, e.g., to run process() on them or to unload them).
Publish Plugins (Pyblish): For plugins under plugins/publish/, which are special cases, they likely subclass both QiPluginBase and Pyblish’s plugin classes (pyblish.api.InstancePlugin or ContextPlugin). Integrating Pyblish:
Ensure pyblish-base is imported and the plugin classes are recognized by Pyblish. We might use pyblish.api.register_plugin() to register each publish plugin class with the Pyblish system. Alternatively, since QiPluginBase will call their register(), that method in a publish plugin can itself call Pyblish’s registration.
Decide how publishing is triggered. Perhaps an “Publish” action in the UI (or a bus message like publish.start) will cause Qi to invoke Pyblish’s processing. For MVP, a simple approach: if the user clicks “Publish” in an addon UI, the frontend can send a publish.request message. A handler in the addon (or a core service) then calls pyblish.util.publish() to run all registered plugins on the current context. This will execute the process() of each publish plugin. Capturing results and errors can then be reported back via the UI.
Other Plugin Types:
Creators/Loaders: These might be invoked via UI actions (e.g., user chooses to create a new asset, which triggers a specific plugin’s process()). The addon’s UI can send a bus message that targets a particular plugin. Alternatively, the addon can expose a direct function that the UI calls via a REST endpoint. For MVP, focus on at least being able to call a plugin manually to see it work.
Hooks: These should automatically execute on certain lifecycle events (e.g., after loading an asset, or on app close). Implement event triggers: for example, after an addon registers, run any hook plugins of type “onStartup”; on shutdown, run “onExit” hooks. This requires defining conventions (maybe hook plugins are named for events). This could be postponed until basic manual plugin execution works.
Actions: These often correspond to menu or UI actions. For instance, an Action plugin might represent a menu item in Ftrack or Qi UI. Once the add-ons and UI are connected, we can map these so that selecting an action in the UI triggers the plugin’s process() method.
Validation: Create a few dummy plugin classes (in the skeleton addon or a test addon) to verify the mechanism. For example, a simple Creator plugin that prints “Hello” when run, or a Publish plugin that always succeeds. Ensure that:
They are discovered and instantiated during addon load (check logs or debugger).
Their register() method attaches any bus handlers (if they use hub.on).
You can call their process() either via a direct method (for testing) or by simulating the event that should trigger them.
Pyblish UI (if any): Pyblish has a UI (Pyblish QML) typically used in pipelines. Decide if Qi will leverage that or provide its own. For MVP, it’s acceptable to run Pyblish headlessly and use Qi’s UI to show results. Full Pyblish UI integration can be a future enhancement.
Completing this step means Qi’s extensibility via plugins is operational. Users (or rather pipeline developers) can add new behaviors by writing plugins in addons, and Qi will load and execute them at the appropriate times. It realizes the “plugin lifecycle” concept from the architecture. We should see the Pyblish-based publish flow working end-to-end for a trivial case, proving the pipeline concept.

### 5. DCC Host Launch & Session Management
Now that the core app can load addons and plugins, we can tackle launching external DCC applications through those addons:
Environment Setup: Define how bundles carry environment definitions for each DCC (e.g., environment variables, which plugins to auto-load in the DCC, etc.). Perhaps in the bundle config or addon config there are entries for this. For MVP, pick one DCC (say Maya or Nuke, or even a dummy Python process if those aren’t accessible) to integrate as a proof of concept.
Host Addon: Create an addon with role="host" (if using roles) or some indicator that it can launch a host. This addon’s responsibility is to launch a specific DCC. For instance, an addon “maya-host” that knows how to start Maya:
In its register(), it could add a tray menu item or UI button “Launch Maya” (via some hub topic like host.launch.maya).
It subscribes to that topic; when triggered, it executes the launch: e.g., uses subprocess.Popen(["maya.exe"], env=prepared_env). The environment should include anything needed for Qi: particularly, a way to auto-run Qi’s client code on Maya startup.
To accomplish the latter, one approach is: set MAYA_SCRIPT_PATH or use a Maya env var to point to a userSetup script that, when Maya launches, it executes Python code to connect back to Qi. For a simpler approach not requiring real Maya scripting, you could create a stub “dcc_simulator.py” that on startup simply opens a WebSocket to Qi and identifies as, say, logical_id="maya-session". Then treat that as a DCC.
The goal is to simulate or perform: a child process starts, then calls Qi’s /ws endpoint sending a QiSession with parent_logical_id = main app’s logical id (probably "qi-main"). We might generate a session token for the child to use as well if security is a concern, but for MVP, not necessary on localhost.
Qi Client in DCC: Ensure that the Qi package (or a lightweight client library) is available to the DCC process. Possibly, since Qi is pip-installable, the host addon can ensure the PYTHONPATH includes Qi, and then in Maya’s startup it does import qi; qi.start_client("maya-session", parent="qi-main"). You might write a small function in Qi that establishes a WebSocket connection from the client side (or simply instruct the DCC to run a script that uses websockets or httpx to connect).
This aspect can be complex; for MVP, even launching a dummy Python script that connects as a client will prove the concept.
Session Tracking: When the DCC child connects, QiConnectionManager will register it with parent-child linkage. We should test that by seeing if QiHub.on_event("register") hooks (which we can set up in the Host addon or core) get called for the new session. Possibly, add a handler to automatically open a UI or send a welcome message to the new DCC session.
Tear-down: On main app exit, ensure child processes terminate. Implement SessionManager.teardown_all() – which could simply iterate over known child PIDs spawned and kill them gracefully. The Host addon can register an on_event("unregister") for the parent (main) session to trigger cleanup of its launched processes.
Also handle if a user explicitly closes a DCC: if the DCC process exits or disconnects, QiConnectionManager will call unregister on that session. Perhaps catch that event (on_event("unregister")) to update UI (e.g., remove an indicator that DCC is active).
Verification: Test by launching the host process from Qi and establishing a ping-pong:
From Qi main, send a message to the DCC session (like hub.request to logical_id "maya-session") and get a reply, or vice versa. This will demonstrate that the bus communication works across processes. For instance, the DCC on connect could immediately send an event "host.ready" that Qi logs.
Confirm that closing Qi (or invoking a quit) indeed shuts down the DCC. Likewise, if DCC is closed manually, Qi logs the session removal.
Document any manual setup needed (like environment variables for DCC to auto-run the Qi client). Eventually, this could be streamlined by generating launcher scripts.
Completing this will fulfill the “run DCC with correct environment and plugins” goal at a basic level. It proves that Qi can coordinate launching external tools and communicating with them – a hallmark feature of the pipeline app.

### 6. Finalize REST API & Dual-Interface Features
At this stage, most capabilities are in place; now ensure the REST API is brought to parity where appropriate:
Aggregate Addon REST routes: During addon registration (step 1), if addons define REST endpoints (perhaps via FastAPI APIRouter instances in their code), have the addon manager collect them. After all addons are registered, include these routers into qi_server under a common prefix (maybe /api/addonname/…). This allows addons to expose HTTP APIs (for external tools or for their own UI when not using WebSocket).
Implement any missing core routes: e.g., an authenticated route for logout, a route for listing bundles or contexts if needed outside WebSocket.
Documentation & Schema: Use FastAPI’s automatic docs to see all available endpoints. Confirm that for each bus capability there is either a corresponding REST endpoint or a conscious decision that it’s WS-only. For example, quick data fetches (project lists, etc.) might be nice to have via HTTP GET for scripting without needing the full WS client.
JWT Auth: Now that we have a token from the Auth addon, integrate FastAPI’s JWT middleware. Possibly use a library like fastapi_jwt_auth or a custom dependency. The token issued at login can be a simple JWT signed with a secret. Store it in the frontend (perhaps as a cookie or in local storage) and include it in REST calls (or as a query param for the WebView initial URL – indeed, QiWindowManager could embed the token in the ?session_id or a separate param so that the UI can use it). Then:
Protect the /ws handshake: modify the WebSocket endpoint to require a valid token in the initial JSON (you can add a token field to QiSession model, and check it on connect).
Protect HTTP routes: apply a Depends(verify_token) on any sensitive route (most of them, possibly).
This will bring the security closer to production needs, though for MVP in a closed network, it’s optional. However, implementing it now is easier than retrofitting later.
Bus vs REST trade-offs: Evaluate if some actions currently only via WS should also be exposed via REST for completeness. For instance, triggering a publish could also be an HTTP POST to an endpoint (allowing automation via scripts). Implement as needed by simply calling into the same logic.
Testing: Use an HTTP client (like curl or httpx) to hit the new API endpoints with and without token to ensure auth works. Also test that the app’s own UI can still communicate (the WebView likely uses the WS primarily, but any fetch it does to the server should carry the token if required).
By the end of this step, Qi will have a fully functional dual API: real-time messaging for internal and UI communication, and a REST interface for integration and external access. Both should respect the authentication model. This satisfies the remaining architectural goal of a unified bus/REST surface.

### 7. Polish, Stabilize & Prepare MVP Release
Finally, focus on improving stability and covering any feature gaps required for an MVP (Minimum Viable Product) release:
Error handling & Logging: Go through each subsystem and ensure errors are caught and logged meaningfully. For example, if an addon fails to load a plugin, it should continue loading others and log that one failed. If a bus handler throws an exception, it’s logged (the bus already does this).
Graceful Shutdown: Implement the shutdown sequence (spec step 8):
When the user exits (e.g., via tray “Quit” or closing main window), call GuiManager.quit() which should orchestrate closing all windows and tray, then signal all sessions to teardown. Possibly send a shutdown event over the bus so addons can handle any cleanup (the spec mentions addon .close() hooks).
Stop the FastAPI server (uvicorn thread). Currently, the code calls server_thread.join() and then os._exit(0) abruptly. Replace this with a cleaner shutdown: call uvicorn.Server.should_exit = True or use uvicorn.stop(), then join.
Ensure child DCC processes are terminated if still running (from step 5).
This will prevent resource leaks and ensure data (like settings overrides) are flushed to disk.
- User Experience Tweaks:
Enable the tray icon now that the core is working. Implement QiTrayManager using pystray: display an icon, and menu items for common actions (Open/Close windows, Quit, etc.). Hook these menu actions to hub events or direct function calls.
Make sure windows launched are brought to front and not hidden behind others (PyWebView config might need tweaks).
Verify that the UI (Svelte apps) can communicate over the WS smoothly – fix any protocol issues.
Possibly implement a basic “home” addon that provides the main dashboard UI after login (showing user info, projects, etc., and letting user open specific tool UIs). The skeleton addon might serve this purpose if expanded.
- Documentation: Update the README and any documentation to reflect how the system works, so other developers or users can test the MVP. Include how to configure addon paths, how to package an addon, etc.
- Testing & Hardening: Run through common scenarios:
Start app with no internet (does it still work with local data?).
Fail login and retry.
Launch DCC and kill it, see if Qi remains stable.
Try invalid operations (like two logins simultaneously, or patching settings with wrong type) and ensure graceful behavior.
Perhaps write automated tests for addon loading and plugin execution, similar to how message bus has tests.
Prioritize fixes for any critical bugs found during testing. Since the hub and server were already fairly solid, focus likely on the newly added parts (addon system and host launching).

By following these steps, we prioritize the backbone of the system (addons and messaging) first, then layered features (auth, settings, plugins), and finally the auxiliary but important pieces (DCC integration, REST, tray UI). This sequence ensures that earlier tasks lay the foundation for later ones – for example, without addon loading, we can’t do auth or plugin loading properly. The end result after step 7 will be a Qi application that is much closer to the envisioned architecture: it will allow login (even if to a dummy DB), load a defined bundle of addons, present UIs, let users perform some pipeline actions (create/load/publish in a basic form), possibly launch a DCC tool, and communicate over a robust internal bus. The system will still need further refinements (e.g., real Ftrack integration, more plugin types, better UI/UX), but it will be a functioning MVP demonstrating the core value: a unified pipeline desktop app with extensible addons, a dual API, and the ability to orchestrate DCC applications in a production context.

## SECOND REPO SCAN + PLANNING COMMENTS

1 - Yes, Addon Manager needs to be set up.

2 - As we were saying since data is an integral part of the system, we should think of it as a service and not an addon, residing under QiDbManager. Auth is one of the adapters needed. the adapters can be addons, but the db is always required so it may be a better fit to feature it as a service?

3 - All overriding and merging needs to be coded. I'd like the QiSettingsManager to be the sole responsible of managing settings (along with QiDbManager to persist data and authorize handling). This will be able to extend the rest api surface with /settings/<addon>/<...> and also provide directly from python. See my answers on your previous plan to know more.

4 - I'd like a single Plugin api for devs, so pyblish will nee dto be abstracted (by calling its functions in out lifetime events?). Ui for pyblish will be custom coded: no pyblish gui will be needed or used. We can start headless and just provide log info or basic Ui reporting at start.

5 - Yes. Noted.

6 - Yes, Noted. For the most part we will be relying on WS and the bus, rest will only be mandatory for settings at start.

7 - Crossing fingers we can make it :)